---
id: release-notes
title: "發行說明"
toc_max_heading_level: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## 版本 1.47

### 網路標籤改進

追蹤檢視器中的 Network 分頁有幾個不錯的改進:

- 按資產類型和 URL 過濾
- 更好地顯示查詢字串參數
- 字體資產預覽

![Network tab now has filters](https://github.com/user-attachments/assets/4bd1b67d-90bd-438b-a227-00b9e86872e2)

### 雜項

- `mcr.microsoft.com/playwright-java:v1.47.0` 現在提供基於 Ubuntu 24.04 Noble 的 Playwright 映像。要使用基於 22.02 jammy 的映像，請改用 `mcr.microsoft.com/playwright-java:v1.47.0-jammy`。
- 現在可以通過將 `cert` 和 `key` 作為位元組陣列傳遞，而不是文件路徑，從記憶體中傳遞 TLS 客戶端證書。
- [Locator.selectOption()](/api/class-locator.mdx#locator-select-option) 中的 `noWaitAfter` 已被棄用。
- 我們已經看到 WebGL 在 GitHub Actions `macos-13` 上的 Webkit 表現不正常的報告。我們建議將 GitHub Actions 升級到 `macos-14`。

### 瀏覽器版本

- Chromium 129.0.6668.29
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 128
- Microsoft Edge 128

## Version 1.46

### TLS Client Certificates

Playwright 現在允許提供客戶端憑證，以便伺服器可以驗證它們，如 TLS 客戶端驗證所指定的。

您可以將客戶端證書作為 [Browser.newContext()](/api/class-browser.mdx#browser-new-context) 和 [APIRequest.newContext()](/api/class-apirequest.mdx#api-request-new-context) 的參數。以下程式碼片段為 `https://example.com` 設定客戶端證書:

```java
BrowserContext context = browser.newContext(new Browser.NewContextOptions()
    .setClientCertificates(asList(new ClientCertificate("https://example.com")
          .setCertPath(Paths.get("client-certificates/cert.pem"))
          .setKeyPath(Paths.get("client-certificates/key.pem")))));
```

### 追蹤檢視器更新

- 現在在附件窗格中內嵌顯示文字附件的內容。
- 新增設定以顯示/隱藏路由操作，如 [Route.resume()](https://ollama.com/api/class-route.mdx#route-continue)。
- 請求方法和狀態顯示在網路詳細資訊標籤中。
- 新按鈕可將來源檔案位置複製到剪貼簿。
- Metadata 窗格現在顯示 `baseURL`。

### 雜項

- 新的 `maxRetries` 選項在 [APIRequestContext.fetch()](/api/class-apirequestcontext.mdx#api-request-context-fetch) 中，當 `ECONNRESET` 網路錯誤時會重試。

### 瀏覽器版本

- Chromium 128.0.6613.18
- Mozilla Firefox 128.0
- WebKit 18.0

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 127
- Microsoft Edge 127

## Version 1.45

### 時鐘

利用新的 [Clock] API 允許在測試中操作和控制時間，以驗證與時間相關的行為。此 API 涵蓋許多常見情境，包括:

* 使用預定義時間進行測試;
* 保持一致的時間和計時器;
* 監控不活動狀態;
* 手動計時。

```java
// Initialize clock with some time before the test time and let the page load
// naturally. `Date.now` will progress as the timers fire.
page.clock().install(new Clock.InstallOptions().setTime("2024-02-02T08:00:00"));
page.navigate("http://localhost:3333");
Locator locator = page.getByTestId("current-time");

// Pretend that the user closed the laptop lid and opened it again at 10am.
// Pause the time once reached that point.
page.clock().pauseAt("2024-02-02T10:00:00");

// Assert the page state.
assertThat(locator).hasText("2/2/2024, 10:00:00 AM");

// Close the laptop lid again and open it at 10:30am.
page.clock().fastForward("30:00");
assertThat(locator).hasText("2/2/2024, 10:30:00 AM");
```

請參閱[時鐘指南](./clock.mdx)以獲取更多資訊。

### 雜項

- 方法 [Locator.setInputFiles()](/api/class-locator.mdx#locator-set-input-files) 現在支援上傳 `<input type=file webkitdirectory>` 元素的目錄。

  ```java
  page.getByLabel("Upload directory").setInputFiles(Paths.get("mydir"));
  ```

- 多個方法如 [Locator.click()](/api/class-locator.mdx#locator-click) 或 [Locator.press()](/api/class-locator.mdx#locator-press) 現在支援 `ControlOrMeta` 修飾鍵。此鍵在 macOS 上對應 `Meta`，在 Windows 和 Linux 上對應 `Control`。

  ```java
  // 按下常見的鍵盤快捷鍵 Control+S 或 Meta+S 以觸發 "Save" 操作。
  page.keyboard.press("ControlOrMeta+S");
  ```

- 新屬性 `httpCredentials.send` 在 [APIRequest.newContext()](/api/class-apirequest.mdx#api-request-new-context) 中允許選擇總是發送 `Authorization` 標頭或僅在回應 `401 Unauthorized` 時發送。
- Playwright 現在支援 Ubuntu 24.04 上的 Chromium、Firefox 和 WebKit。
- v1.45 是最後一個針對 macOS 12 Monterey 獲得 WebKit 更新的版本。請更新 macOS 以繼續使用最新的 WebKit。

### 瀏覽器版本

* Chromium 127.0.6533.5
* Mozilla Firefox 127.0
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 126
* Microsoft Edge 126

## 版本 1.44

### 新的 API

**無障礙聲明**

- [assertThat(locator).hasAccessibleName()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name) 檢查元素是否具有指定的可存取名稱:

  ```java
  Locator locator = page.getByRole(AriaRole.BUTTON);
  assertThat(locator).hasAccessibleName("Submit");
  ```

- [assertThat(locator).hasAccessibleDescription()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description) 檢查元素是否具有指定的可存取描述:

  ```java
  Locator locator = page.getByRole(AriaRole.BUTTON);
  assertThat(locator).hasAccessibleDescription("Upload a photo");
  ```

- [assertThat(locator).hasRole()](/api/class-locatorassertions.mdx#locator-assertions-to-have-role) 檢查元素是否具有指定的 ARIA 角色:

  ```java
  Locator locator = page.getByTestId("save-button");
  assertThat(locator).hasRole(AriaRole.BUTTON);
  ```

**定位器處理程式**

- 執行使用 [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) 添加的處理程式後，Playwright 現在會等待觸發處理程式的覆蓋層不再可見。你可以使用新的 `setNoWaitAfter` 選項來選擇不使用此行為。
- 你可以在 [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) 中使用新的 `setTimes` 選項來指定處理程式應執行的最大次數。
- [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) 中的處理程式現在接受定位器作為參數。
- 新的 [Page.removeLocatorHandler()](/api/class-page.mdx#page-remove-locator-handler) 方法用於移除先前添加的定位器處理程式。

```java
Locator locator = page.getByText("This interstitial covers the button");
page.addLocatorHandler(locator, overlay -> {
  overlay.locator("#close").click();
}, new Page.AddLocatorHandlerOptions().setTimes(3).setNoWaitAfter(true));
// Run your tests that can be interrupted by the overlay.
// ...
page.removeLocatorHandler(locator);
```

**其他選項**

- 新方法 [FormData.append()](https://api/class-formdata.mdx#form-data-append) 允許在 `RequestOptions` 的 [`setMultipart`](./api/class-requestoptions#request-options-set-multipart) 選項中指定具有相同名稱的重複字段:

  ```java
  FormData formData = FormData.create();
  formData.append("file", new FilePayload("f1.js", "text/javascript",
  "var x = 2024;".getBytes(StandardCharsets.UTF_8)));
  formData.append("file", new FilePayload("f2.txt", "text/plain",
    "hello".getBytes(StandardCharsets.UTF_8)));
  APIResponse response = context.request().post("https://example.com/uploadFile", RequestOptions.create().setMultipart(formData));
  ```

- `expect(page).toHaveURL(url)` 現在支持 `setIgnoreCase` [選項](./api/class-pageassertions#page-assertions-to-have-url-option-ignore-case)。

### 瀏覽器版本

* Chromium 125.0.6422.14
* Mozilla Firefox 125.0.1
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 124
* Microsoft Edge 124

## 版本 1.43

### 新的 API

- Method [BrowserContext.clearCookies()](https://playwright.dev/java/docs/api/class-browsercontext#browser-context-clear-cookies) now supports filters to remove only some cookies。

  ```java
  // 清除所有 cookies。
  context.clearCookies();
  // 新增: 清除具有特定名稱的 cookies。
  context.clearCookies(new BrowserContext.ClearCookiesOptions().setName("session-id"));
  // 新增: 清除特定域的 cookies。
  context.clearCookies(new BrowserContext.ClearCookiesOptions().setDomain("my-origin.com"));
  ```

- New method [Locator.contentFrame()](https://playwright.dev/java/docs/api/class-locator#locator-content-frame) converts a [Locator] 物件 to a [FrameLocator]。This can be useful when you have a [Locator] 物件 obtained somewhere, and later on would like to interact with the content inside the frame。

  ```java
  Locator locator = page.locator("iframe[name='embedded']");
  // ...
  FrameLocator frameLocator = locator.contentFrame();
  frameLocator.getByRole(AriaRole.BUTTON).click();
  ```

- New method [FrameLocator.owner()](https://playwright.dev/java/docs/api/class-framelocator#frame-locator-owner) converts a [FrameLocator] 物件 to a [Locator]。This can be useful when you have a [FrameLocator] 物件 obtained somewhere, and later on would like to interact with the `iframe` element。

  ```java
  FrameLocator frameLocator = page.frameLocator("iframe[name='embedded']");
  // ...
  Locator locator = frameLocator.owner();
  assertThat(locator).isVisible();
  ```

### 瀏覽器版本

* Chromium 124.0.6367.8
* Mozilla Firefox 124.0
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 123
* Microsoft Edge 123

## Version 1.42

### 實驗性 JUnit 整合

新增新的 [`@UsePlaywright`](./junit.mdx) 註解到您的測試類別，以便在測試方法中開始使用 Playwright fixtures 來測試 [Page]、[BrowserContext]、[Browser]、[APIRequestContext] 和 [Playwright]。

```java
package org.example;

import com.microsoft.playwright.Page;
import com.microsoft.playwright.junit.UsePlaywright;
import org.junit.jupiter.api.Test;

import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;

@UsePlaywright
public class TestExample {
  void shouldNavigateToInstallationGuide(Page page) {
    page.navigate("https://playwright.dev/java/");
    page.getByRole(AriaRole.LINK, new Page.GetByRoleOptions().setName("Docs")).click();
    assertThat(page.getByRole(AriaRole.HEADING, new Page.GetByRoleOptions().setName("Installation"))).isVisible();
  }

  @Test
  void shouldCheckTheBox(Page page) {
    page.setContent("<input id='checkbox' type='checkbox'></input>");
    page.locator("input").check();
    assertEquals(true, page.evaluate("window['checkbox'].checked"));
  }

  @Test
  void shouldSearchWiki(Page page) {
    page.navigate("https://www.wikipedia.org/");
    page.locator("input[name=\"search\"]").click();
    page.locator("input[name=\"search\"]").fill("playwright");
    page.locator("input[name=\"search\"]").press("Enter");
    assertThat(page).hasURL("https://en.wikipedia.org/wiki/Playwright");
  }
}
```

在上述範例中，所有三個測試方法使用相同的 [Browser]。每個測試使用其自己的 [BrowserContext] 和 [Page]。

**自訂選項**

實作您自己的 `OptionsFactory` 來使用自訂配置初始化這些夾具。

```java
import com.microsoft.playwright.junit.Options;
import com.microsoft.playwright.junit.OptionsFactory;
import com.microsoft.playwright.junit.UsePlaywright;

@UsePlaywright(MyTest.CustomOptions.class)
public class MyTest {

  public static class CustomOptions implements OptionsFactory {
    @Override
    public Options getOptions() {
      return new Options()
          .setHeadless(false)
          .setContextOption(new Browser.NewContextOptions()
              .setBaseURL("https://github.com"))
          .setApiRequestOptions(new APIRequest.NewContextOptions()
              .setBaseURL("https://playwright.dev"));
    }
  }

  @Test
  public void testWithCustomOptions(Page page, APIRequestContext request) {
    page.navigate("/");
    assertThat(page).hasURL(Pattern.compile("github"));

    APIResponse response = request.get("/");
    assertTrue(response.text().contains("Playwright"));
  }
}
```

了解更多關於我們 [JUnit 指南](./junit.mdx) 中的 fixtures。

### 新定位器處理程式

新方法 [Page.addLocatorHandler()](https://api/class-page.mdx#page-add-locator-handler) 註冊了一個回呼，當指定元素變得可見時將會被呼叫，並且可能會阻擋 Playwright 操作。回呼可以去除覆蓋層。這裡有一個範例，當 cookie 對話框出現時將其關閉。

```java
// Setup the handler.
page.addLocatorHandler(
    page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Hej! You are in control of your cookies.")),
    () - > {
        page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Accept all")).click();
    });
// Write the test as usual.
page.navigate("https://www.ikea.com/");
page.getByRole(AriaRole.LINK, new Page.GetByRoleOptions().setName("Collection of blue and white")).click();
assertThat(page.getByRole(AriaRole.HEADING, new Page.GetByRoleOptions().setName("Light and easy"))).isVisible();
```

### 新的 API

- [Page.pdf()](/api/class-page.mdx#page-pdf) 接受兩個新選項 `tagged` 和 `outline`。

### 公告

* ⚠️ Ubuntu 18 已不再支援。

### 瀏覽器版本

* Chromium 123.0.6312.4
* Mozilla Firefox 123.0
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 122
* Microsoft Edge 123

## Version 1.41

### 新的 API

- 新方法 [Page.unrouteAll()](/api/class-page.mdx#page-unroute-all) 移除所有由 [Page.route()](/api/class-page.mdx#page-route) 和 [Page.routeFromHAR()](/api/class-page.mdx#page-route-from-har) 註冊的路由。
- 新方法 [BrowserContext.unrouteAll()](/api/class-browsercontext.mdx#browser-context-unroute-all) 移除所有由 [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) 和 [BrowserContext.routeFromHAR()](/api/class-browsercontext.mdx#browser-context-route-from-har) 註冊的路由。
- 新選項 `style` 在 [Page.screenshot()](/api/class-page.mdx#page-screenshot) 和 [Locator.screenshot()](/api/class-locator.mdx#locator-screenshot) 中，在截圖前向頁面添加自定義 CSS。

### 瀏覽器版本

* Chromium 121.0.6167.57
* Mozilla Firefox 121.0
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 120
* Microsoft Edge 120

## Version 1.40

### 測試程式碼產生器更新

![Playwright Test Generator](https://github.com/microsoft/playwright/assets/9881434/e8d67e2e-f36d-4301-8631-023948d3e190)

產生斷言的新工具:

- "Assert visibility" 工具生成 [assertThat(locator).isVisible](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible)。
- "Assert value" 工具生成 [assertThat(locator).hasValue](/api/class-locatorassertions.mdx#locator-assertions-to-have-value)。
- "Assert text" 工具生成 [assertThat(locator).containsText](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text)。

這裡是一個帶有斷言的生成測試範例:

```java
page.navigate("https://playwright.dev/");
page.getByRole(AriaRole.LINK, new Page.GetByRoleOptions().setName("Get started")).click();
assertThat(page.getByLabel("Breadcrumbs").getByRole(AriaRole.LIST)).containsText("Installation");
assertThat(page.getByLabel("Search")).isVisible();
page.getByLabel("Search").click();
page.getByPlaceholder("Search docs").fill("locator");
assertThat(page.getByPlaceholder("Search docs")).hasValue("locator");
```

### 新的 API

- 選項 `reason` 在 [Page.close()](/api/class-page.mdx#page-close), [BrowserContext.close()](/api/class-browsercontext.mdx#browser-context-close) 和 [Browser.close()](/api/class-browser.mdx#browser-close)。關閉原因會報告所有因關閉而中斷的操作。
- 選項 `firefoxUserPrefs` 在 [BrowserType.launchPersistentContext()](/api/class-browsertype.mdx#browser-type-launch-persistent-context)。

### 其他變更

- 方法 [Download.path()](/api/class-download.mdx#download-path) 和 [Download.createReadStream()](/api/class-download.mdx#download-create-read-stream) 對於失敗和取消的下載拋出錯誤。

### 瀏覽器版本

* Chromium 120.0.6099.28
* Mozilla Firefox 119.0
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 119
* Microsoft Edge 119

## Version 1.39

Evergreen 瀏覽器更新。

### 瀏覽器版本

* Chromium 119.0.6045.9
* Mozilla Firefox 118.0.1
* WebKit 17.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 118
* Microsoft Edge 118

## Version 1.38

### 追蹤檢視器更新

![Playwright Trace Viewer](https://github.com/microsoft/playwright/assets/746130/0c41e20d-c54b-4600-8ca8-1cbb6393ddef)

1. 放大時間範圍。
1. 網路面板重新設計。

### 新的 API

- [BrowserContext.onWebError(handler)](/api/class-browsercontext.mdx#browser-context-event-web-error)
- [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially)

### 棄用

* 以下方法已被棄用: [Page.type()](/api/class-page.mdx#page-type), [Frame.type()](/api/class-frame.mdx#frame-type), [Locator.type()](/api/class-locator.mdx#locator-type) 和 [ElementHandle.type()](/api/class-elementhandle.mdx#element-handle-type)。請改用 [Locator.fill()](/api/class-locator.mdx#locator-fill)，它更快。僅在頁面上有特殊鍵盤處理且需要逐個按鍵時使用 [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially)。

### 瀏覽器版本

* Chromium 117.0.5938.62
* Mozilla Firefox 117.0
* WebKit 17.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 116
* Microsoft Edge 116

## Version 1.37

### 新的 API

- 新方法 [BrowserContext.newCDPSession()](/api/class-browsercontext.mdx#browser-context-new-cdp-session) 和 [Browser.newBrowserCDPSession()](/api/class-browser.mdx#browser-new-browser-cdp-session) 分別為頁面和瀏覽器建立一個 [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) 會話。

  ```java
  CDPSession cdpSession = page.context().newCDPSession(page);
  cdpSession.send("Runtime.enable");

  JsonObject params = new JsonObject();
  params.addProperty("expression", "window.foo = 'bar'");
  cdpSession.send("Runtime.evaluate", params);

  Object foo = page.evaluate("window['foo']");
  assertEquals("bar", foo);
  ```

### 📚 Debian 12 Bookworm 支援

Playwright 現在支援 Debian 12 Bookworm（x86_64 和 arm64）上的 Chromium、Firefox 和 WebKit。如遇到任何問題，請告訴我們！

Linux 支援看起來像這樣:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11 | Debian 12 |
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ | ✅ |

### 瀏覽器版本

* Chromium 116.0.5845.82
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 115
* Microsoft Edge 115

## Version 1.36

🏝️ 夏季維護版本發布。

### 瀏覽器版本

* Chromium 115.0.5790.75
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 114
* Microsoft Edge 114

## Version 1.35

### 重點

* 新選項 `maskColor` 用於方法 [Page.screenshot()](https://api/class-page.mdx#page-screenshot) 和 [Locator.screenshot()](https://api/class-locator.mdx#locator-screenshot) 來更改預設遮罩顏色。
* 新的 `uninstall` CLI 命令來卸載瀏覽器二進位檔：

  ```bash
  $ mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="uninstall" # 移除此安裝所安裝的瀏覽器
  $ mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="uninstall --all" # 移除所有曾經安裝的 Playwright 瀏覽器
  ```

### 瀏覽器版本

* Chromium 115.0.5790.13
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 114
* Microsoft Edge 114

## 版本 1.34

### 重點

* 新的 [Locator.and()](/api/class-locator.mdx#locator-and) 用於建立同時匹配兩個定位器的定位器。

  ```java
  Locator button = page.getByRole(AriaRole.BUTTON).and(page.getByTitle("Subscribe"));
  ```

* 新的事件 [BrowserContext.onConsoleMessage(handler)](/api/class-browsercontext.mdx#browser-context-event-console) 和 [BrowserContext.onDialog(handler)](/api/class-browsercontext.mdx#browser-context-event-dialog) 用於訂閱來自給定瀏覽器上下文的任何頁面上的任何對話框和控制台訊息。使用新方法 [ConsoleMessage.page()](/api/class-consolemessage.mdx#console-message-page) 和 [Dialog.page()](/api/class-dialog.mdx#dialog-page) 來精確定位事件來源。

### 瀏覽器版本

* Chromium 114.0.5735.26
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 113
* Microsoft Edge 113

## 版本 1.33

### 定位器更新

* 使用 [Locator.or()](/api/class-locator.mdx#locator-or) 建立一個符合兩個定位器之一的定位器。考慮一個情境，你想點擊 "New email" 按鈕，但有時會彈出一個安全設定對話框。在這種情況下，你可以等待 "New email" 按鈕或對話框並相應地操作：

  ```java
  Locator newEmail = page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("New email"));
  Locator dialog = page.getByText("Confirm security settings");
  assertThat(newEmail.or(dialog)).isVisible();
  if (dialog.isVisible())
    page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Dismiss")).click();
  newEmail.click();
  ```

* 在 [Locator.filter()](/api/class-locator.mdx#locator-filter) 中使用新的選項 `hasNot` 和 `hasNotText` 來找到**不符合**某些條件的元素。

  ```java
  Locator rowLocator = page.locator("tr");
  rowLocator
      .filter(new Locator.FilterOptions().setHasNotText("text in column 1"))
      .filter(new Locator.FilterOptions().setHasNot(
        page.getByRole(AriaRole.BUTTON,
          new Page.GetByRoleOptions().setName("column 2 button" )))
      .screenshot();
  ```

* 使用新的網頁優先斷言 [assertThat(locator).isAttached()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached) 來確保元素存在於頁面的 DOM 中。不要與 [assertThat(locator).isVisible()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible) 混淆，後者確保元素既已附加又可見。

### 新的 API

- [Locator.or()](/api/class-locator.mdx#locator-or)
- 新選項 `hasNot` 在 [Locator.filter()](/api/class-locator.mdx#locator-filter)
- 新選項 `hasNotText` 在 [Locator.filter()](/api/class-locator.mdx#locator-filter)
- [assertThat(locator).isAttached()](https://api/class-locatorassertions.mdx#locator-assertions-to-be-attached)
- 新選項 `timeout` 在 [Route.fetch()](https://api/class-route.mdx#route-fetch)

### 其他亮點

- 原生支援 Apple Silicon - Playwright 現在無需 Rosetta 即可執行
- 新增 Ubuntu 22.04 (Jammy) Docker 映像檔

### ⚠️ 重大變更

* `mcr.microsoft.com/playwright/java:v1.33.0` 現在提供基於 Ubuntu Jammy 的 Playwright 映像。要使用基於 focal 的映像，請改用 `mcr.microsoft.com/playwright/java:v1.33.0-focal`。

### 瀏覽器版本

* Chromium 113.0.5672.53
* Mozilla Firefox 112.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 112
* Microsoft Edge 112

## 版本 1.32

### 新的 API

- 新選項 `updateMode` 和 `updateContent` 在 [Page.routeFromHAR()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.routeFromHAR()](/api/class-browsercontext.mdx#browser-context-route-from-har)。
- 鏈接現有的定位器物件，詳情請參閱 [定位器文件](./locators.mdx#matching-inside-a-locator)。
- 新選項 `name` 在方法 [Tracing.startChunk()](/api/class-tracing.mdx#tracing-start-chunk)。

### 瀏覽器版本

* Chromium 112.0.5615.29
* Mozilla Firefox 111.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 111
* Microsoft Edge 111

## 版本 1.31

### 新的 API

- 新的斷言 [assertThat(locator).isInViewport()](https://playwright.dev/java/docs/api/class-locatorassertions#locator-assertions-to-be-in-viewport) 確保定位器指向與視窗相交的元素，根據 [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)。

  ```java
  Locator locator = page.getByRole(AriaRole.BUTTON);

  // 確保元素的至少一部分與視窗相交。
  assertThat(locator).isInViewport();

  // 確保元素完全在視窗外。
  assertThat(locator).not().isInViewport();

  // 確保元素至少有一半與視窗相交。
  assertThat(locator).isInViewport(new LocatorAssertions.IsInViewportOptions().setRatio(0.5));
  ```

### 雜項

- 現在可以在單獨的視窗中打開追蹤檢視器中的 DOM 快照。
- 新選項 `Route.fetch.maxRedirects` 用於方法 [Route.fetch()](/api/class-route.mdx#route-fetch)。
- Playwright 現在支援 Debian 11 arm64。
- 官方 [docker images](./docker.mdx) 現在包含 Node 18 而不是 Node 16。

### 瀏覽器版本

* Chromium 111.0.5563.19
* Mozilla Firefox 109.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 110
* Microsoft Edge 110

## 版本 1.30

### 瀏覽器版本

* Chromium 110.0.5481.38
* Mozilla Firefox 108.0.2
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 109
* Microsoft Edge 109

## Version 1.29

### 新的 API

- 新方法 [Route.fetch()](https://ollama.com/api/class-route.mdx#route-fetch):

  ```java
  page.route("**/api/settings", route -> {
    // 獲取原始設定。
    APIResponse response = route.fetch();
    // 將設定主題強制為預定義值。
    String body = response.text().replace("\"theme\":\"default\"",
      "\"theme\":\"Solorized\"");
    // 用修改後的資料回應。
    route.fulfill(new Route.FulfillOptions().setResponse(response).setBody(body));
  });
  ```

- 新方法 [Locator.all()](https://ollama.com/api/class-locator.mdx#locator-all) 來迭代所有匹配的元素:

  ```java
  // 檢查所有的複選框！
  Locator checkboxes = page.getByRole(AriaRole.CHECKBOX);
  for (Locator checkbox : checkboxes.all())
    checkbox.check();
  ```

- [Locator.selectOption()](https://ollama.com/api/class-locator.mdx#locator-select-option) 現在可以通過值或標籤匹配:

  ```html
  <select multiple>
    <option value="red">Red</div>
    <option value="green">Green</div>
    <option value="blue">Blue</div>
  </select>
  ```

  ```java
  element.selectOption("Red");
  ```

### 瀏覽器版本

* Chromium 109.0.5414.46
* Mozilla Firefox 107.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 108
* Microsoft Edge 108

## 版本 1.28

### Playwright 工具

* **程式碼產生器中的即時定位器。** 使用 "Explore" 工具為頁面上的任意元素生成定位器。

![定位器探索器](https://user-images.githubusercontent.com/9798949/202293631-2f402cc2-35fb-4877-8ea1-82265fbbc232.png)

### 新的 API

- [Locator.blur()](https://api/class-locator.mdx#locator-blur)
- [Locator.clear()](https://api/class-locator.mdx#locator-clear)

### 瀏覽器版本

* Chromium 108.0.5359.29
* Mozilla Firefox 106.0
* WebKit 16.4

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 107
* Microsoft Edge 107

## 版本 1.27

### 定位器

使用這些新的 API，寫定位器是一種樂趣:

- [Page.getByText()](https://ollama.com/library) 根據文字內容定位。
- [Page.getByRole()](https://ollama.com/library) 根據 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 定位。
- [Page.getByLabel()](https://ollama.com/library) 根據關聯標籤的文字定位表單控制項。
- [Page.getByTestId()](https://ollama.com/library) 根據 `data-testid` 屬性（其他屬性可以配置）定位元素。
- [Page.getByPlaceholder()](https://ollama.com/library) 根據佔位符定位輸入框。
- [Page.getByAltText()](https://ollama.com/library) 根據替代文字（通常是圖片）定位元素。
- [Page.getByTitle()](https://ollama.com/library) 根據標題定位元素。

```java
page.getByLabel("User Name").fill("John");

page.getByLabel("Password").fill("secret-password");

page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Sign in")).click();

assertThat(page.getByText("Welcome, John!")).isVisible();
```

所有相同的方法也可在 [Locator]、[FrameLocator] 和 [Frame] 類別上使用。

### 其他亮點

- 如 v1.25 中所宣布，Ubuntu 18 將於 2022 年 12 月起不再支援。此外，從下一個 Playwright 版本開始，Ubuntu 18 將不再有 WebKit 更新。

### 行為變更

- [assertThat(locator).hasAttribute()](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute。

  ```java
  assertThat(page.getByRole(AriaRole.BUTTON)).hasAttribute("disabled", "");
  ```

### 瀏覽器版本

* Chromium 107.0.5304.18
* Mozilla Firefox 105.0.1
* WebKit 16.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 106
* Microsoft Edge 106

## Version 1.26

### 斷言

- 新選項 `enabled` 用於 [assertThat(locator).isEnabled()](https://ollama.com/api/class-locatorassertions.mdx#locator-assertions-to-be-enabled)。
- [assertThat(locator).hasText()](https://ollama.com/api/class-locatorassertions.mdx#locator-assertions-to-have-text) 現在穿透開放的 shadow roots。
- 新選項 `editable` 用於 [assertThat(locator).isEditable()](https://ollama.com/api/class-locatorassertions.mdx#locator-assertions-to-be-editable)。
- 新選項 `visible` 用於 [assertThat(locator).isVisible()](https://ollama.com/api/class-locatorassertions.mdx#locator-assertions-to-be-visible)。

### 其他亮點

- 新選項 `setMaxRedirects` 用於 [APIRequestContext.get()](https://ollama.com/library#api-request-context-get) 和其他用來限制重定向次數。
- Docker 映像現在使用 OpenJDK 17。

### 行為變更

一堆 Playwright APIs 已經支援 `setWaitUntil(WaitUntilState.DOMCONTENTLOADED)` 選項。例如:

```java
page.navigate("https://playwright.dev", new Page.NavigateOptions().setWaitUntil(WaitUntilState.DOMCONTENTLOADED));
```

在 1.26 之前，這會等待所有 iframes 觸發 `DOMContentLoaded` 事件。

為了符合 web 規範，`WaitUntilState.DOMCONTENTLOADED` 值僅等待目標框架觸發 `'DOMContentLoaded'` 事件。使用 `setWaitUntil(WaitUntilState.LOAD)` 等待所有 iframes。

### 瀏覽器版本

* Chromium 106.0.5249.30
* Mozilla Firefox 104.0
* WebKit 16.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 105
* Microsoft Edge 105

## 版本 1.25

### 新的 API 和變更

- 預設斷言逾時現在可以使用[`setDefaultAssertionTimeout`](./api/class-playwrightassertions#playwright-assertions-set-default-assertion-timeout) 進行更改。

### 公告

* 🪦 這是最後一個支援 macOS 10.15 的版本（從 1.21 開始棄用）。
* ⚠️ Ubuntu 18 現在已被棄用，並且從 2022 年 12 月起將不再支援。

### 瀏覽器版本

* Chromium 105.0.5195.19
* Mozilla Firefox 103.0
* WebKit 16.0

此版本也針對以下穩定頻道進行了測試:

* Google Chrome 104
* Microsoft Edge 104

## Version 1.24

<div className="embed-youtube">

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9F05o1shxcY" title="YouTube 影片播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>

### 🐂 Debian 11 Bullseye 支援

Playwright 現在支援 Debian 11 Bullseye 在 x86_64 上的 Chromium、Firefox 和 WebKit。如果您遇到任何問題，請告訴我們！

Linux 支援看起來像這樣:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ |

## Version 1.23

### 網路重播

現在你可以將網路流量記錄到 HAR 檔案中，並在你的測試中重新使用這些流量。

記錄網路到 HAR 檔案:

```bash
mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="open --save-har=example.har --save-har-glob='**/api/**' https://example.com"
```

或者，您可以以程式方式記錄 HAR:

```java
BrowserContext context = browser.newContext(new Browser.NewContextOptions()
    .setRecordHarPath(Paths.get("example.har"))
    .setRecordHarUrlFilter("**/api/**"));

// ... Perform actions ...

// Close context to ensure HAR is saved to disk.
context.close();
```

使用新方法 [Page.routeFromHAR()](https://api/class-page.mdx#page-route-from-har) 或 [BrowserContext.routeFromHAR()](https://api/class-browsercontext.mdx#browser-context-route-from-har) 從 [HAR](http://www.softwareishard.com/blog/har-12-spec/) 檔案提供匹配的回應:

```java
context.routeFromHAR(Paths.get("example.har"));
```

在[我們的文件](./mock.mdx#mocking-with-har-files)中閱讀更多內容。

### 進階路由

你現在可以使用 [Route.fallback()](/api/class-route.mdx#route-fallback) 來延遲路由到其他處理程序。

考慮以下範例:

```java
// Remove a header from all requests.
page.route("**/*", route -> {
  Map<String, String> headers = new HashMap<>(route.request().headers());
  headers.remove("X-Secret");
  route.resume(new Route.ResumeOptions().setHeaders(headers));
});

// Abort all images.
page.route("**/*", route -> {
  if ("image".equals(route.request().resourceType()))
    route.abort();
  else
    route.fallback();
});
```

請注意，新的方法 [Page.routeFromHAR()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.routeFromHAR()](/api/class-browsercontext.mdx#browser-context-route-from-har) 也參與路由並且可以被延遲。

### Web-First Assertions Update

* 新方法 [assertThat(locator).hasValues()](/api/class-locatorassertions.mdx#locator-assertions-to-have-values) 來斷言 `<select multiple>` 元素的所有選定值。
* 方法 [assertThat(locator).containsText()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text) 和 [assertThat(locator).hasText()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) 現在接受 `ignoreCase` 選項。

### 雜項

* 如果有一個 service worker 擋住了你的路，你現在可以使用新的上下文選項 `serviceWorkers` 輕鬆禁用它：

  ```java
  BrowserContext context = browser.newContext(new Browser.NewContextOptions()
      .setServiceWorkers(ServiceWorkerPolicy.BLOCK));
  ```

* 使用 `.zip` 路徑作為 `recordHar` 上下文選項會自動壓縮生成的 HAR：

  ```java
  BrowserContext context = browser.newContext(new Browser.NewContextOptions()
      .setRecordHarPath(Paths.get("example.har.zip")));
  ```

* 如果你打算手動編輯 HAR，考慮使用 `"minimal"` HAR 錄製模式，它只記錄對重播至關重要的資訊：

  ```java
  BrowserContext context = browser.newContext(new Browser.NewContextOptions()
      .setRecordHarPath(Paths.get("example.har"))
      .setRecordHarMode(HarMode.MINIMAL));
  ```

* Playwright 現在可以在 Ubuntu 22 amd64 和 Ubuntu 22 arm64 上執行。

## Version 1.22

### 重點

- 允許通過其 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 選擇元素的角色選擇器。

  ```java
  // 點擊具有可訪問名稱 "log in" 的按鈕
  page.locator("role=button[name='log in']").click();
  ```

  閱讀更多在 [我們的文件](./locators.mdx#locate-by-role)。
- 新的 [Locator.filter()](/api/class-locator.mdx#locator-filter) API 用於篩選現有的定位器

  ```java
  Locator buttonsLocator = page.locator("role=button");
  // ...
  Locator submitButton = buttonsLocator.filter(new Locator.FilterOptions().setHasText("Submit"));
  submitButton.click();
  ```

- Playwright for Java 現在支援 **Ubuntu 20.04 ARM64** 和 **Apple M1**。你現在可以在 Apple M1 上、Apple M1 的 Docker 內以及 Raspberry Pi 上執行 Playwright for Java 測試。

## Version 1.21

### 重點

- 新的角色選擇器允許通過其 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 選擇元素。

  ```java
  // 點擊一個可訪問名稱為 "log in" 的按鈕
  page.locator("role=button[name='log in']").click();
  ```

  閱讀更多在 [我們的文件](./locators.mdx#locate-by-role)。
- 新的 `scale` 選項在 [Page.screenshot()](./api/class-page.mdx#page-screenshot) 中，用於較小尺寸的截圖。
- 新的 `caret` 選項在 [Page.screenshot()](./api/class-page.mdx#page-screenshot) 中控制文本插入符號。默認為 `"hide"`。

### 行為變更

- Playwright 現在支援大型檔案上傳 (數百 MB) 透過 [Locator.setInputFiles()](https://api/class-locator.mdx#locator-set-input-files) API。

### 瀏覽器版本

- Chromium 101.0.4951.26
- Mozilla Firefox 98.0.2
- WebKit 15.4

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 100
- Microsoft Edge 100

## Version 1.20

### 重點

- 新的選項用於方法 [Page.screenshot()](/api/class-page.mdx#page-screenshot), [Locator.screenshot()](/api/class-locator.mdx#locator-screenshot) 和 [ElementHandle.screenshot()](/api/class-elementhandle.mdx#element-handle-screenshot):
  * 選項 `ScreenshotAnimations.DISABLED` 將所有 CSS 動畫和過渡倒帶到一致的狀態
  * 選項 `mask: Locator[]` 遮罩給定的元素，並用粉紅色 `#FF00FF` 框覆蓋它們。
- [Trace Viewer](https://playwright.dev/trace-viewer) 現在顯示 [API 測試請求](https://playwright.dev/api-testing)。
- [Locator.highlight()](/api/class-locator.mdx#locator-highlight) 視覺上顯示元素以便於調試。

### 公告

- v1.20 是最後一個針對 macOS 10.15 Catalina 接收 WebKit 更新的版本。請更新 macOS 以繼續使用最新和最棒的 WebKit!

### 瀏覽器版本

- Chromium 101.0.4921.0
- Mozilla Firefox 97.0.1
- WebKit 15.4

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 99
- Microsoft Edge 99

## Version 1.19

### 重點

- Locator 現在支援一個 `has` 選項，確保其內包含另一個 locator:

  ```java
  page.locator("article", new Page.LocatorOptions().setHas(page.locator(".highlight"))).click();
  ```

  閱讀更多在 [locator 文件](./api/class-locator#locator-locator)。
- 新的 [Locator.page()](./api/class-locator.mdx#locator-page)
- [Page.screenshot()](./api/class-page.mdx#page-screenshot) 和 [Locator.screenshot()](./api/class-locator.mdx#locator-screenshot) 現在自動隱藏閃爍的插入點
- Playwright Codegen 現在會產生 locators 和 frame locators

### 瀏覽器版本

- Chromium 100.0.4863.0
- Mozilla Firefox 96.0.1
- WebKit 15.4

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 98
- Microsoft Edge 98

## 版本 1.18

### API 測試

Playwright for Java 1.18 準備推出新的 [API Testing](./api/class-apirequestcontext)，讓你可以直接從 Java 發送請求到伺服器！現在你可以：

- 測試你的伺服器 API
- 在測試中訪問 web 應用程式之前準備伺服器端狀態
- 在瀏覽器中執行一些操作後驗證伺服器端後置條件

要代表 Playwright 的 Page 進行請求，使用 **new [Page.request()](https://api/class-page.mdx#page-request) API**:

```java
// Do a GET request on behalf of page
APIResponse res = page.request().get("http://example.com/foo.json");
```

在我們的 [API 測試指南](./api-testing) 中了解更多資訊。

### Web-First Assertions

Playwright for Java 1.18 準備推出 [Web-First Assertions](./test-assertions)。

考慮以下範例:

```java
...
import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;

public class TestExample {
  ...
  @Test
  void statusBecomesSubmitted() {
    ...
    page.locator("#submit-button").click();
    assertThat(page.locator(".status")).hasText("Submitted");
  }
}
```

Playwright 將會重新測試具有選擇器 `.status` 的節點，直到獲取的節點具有 `"Submitted"` 文本。它將會重新獲取節點並一遍又一遍地檢查，直到滿足條件或達到超時。你可以將這個超時作為選項傳遞。

閱讀更多在 [我們的文件](./test-assertions)。

### 定位器改進

- [Locator.dragTo()](/api/class-locator.mdx#locator-drag-to)
- 每個定位器現在可以選擇性地根據其包含的文本進行過濾:

  ```java
  page.locator("li", new Page.LocatorOptions().setHasText("my item"))
      .locator("button").click();
  ```

  閱讀更多在 [定位器文件](./api/class-locator#locator-locator)。

### Tracing Improvements

[Tracing](./api/class-tracing.mdx) 現在可以將 Java 原始碼嵌入到記錄的追蹤中，使用新的 [`setSources`](./api/class-tracing#tracing-start-option-sources) 選項。

![追蹤-java-來源](https://user-images.githubusercontent.com/746130/150180856-40a7df71-370c-4597-8665-40c77a5e06ad.png)

### 新的 API 和變更

- [`acceptDownloads`](./api/class-browser#browser-new-context-option-accept-downloads) 選項現在預設為 `true`。

### 瀏覽器版本

- Chromium 99.0.4812.0
- Mozilla Firefox 95.0
- WebKit 15.4

此版本也針對以下穩定頻道進行了測試:

- Google Chrome 97
- Microsoft Edge 97

## Version 1.17

### Frame 定位器

Playwright 1.17 準備推出 [frame locators](./api/class-framelocator) - 一個頁面上 iframe 的定位器。Frame locators 捕捉足以獲取 `iframe` 的邏輯，然後在該 iframe 中定位元素。Frame locators 預設是嚴格的，會等待 `iframe` 出現，並且可以用於 Web-First 斷言。



框架定位器可以通過 [Page.frameLocator()](/api/class-page.mdx#page-frame-locator) 或 [Locator.frameLocator()](/api/class-locator.mdx#locator-frame-locator) 方法建立。

```java
Locator locator = page.frameLocator("#my-frame").locator("text=Submit");
locator.click();
```

更多資訊請參見 [我們的文件](./api/class-framelocator)。

### Trace Viewer 更新

Playwright Trace Viewer 現在**可在線使用**，網址為 https://trace.playwright.dev！只需拖放你的 `trace.zip` 文件即可檢查其內容。

> **注意**: 追蹤檔案不會上傳到任何地方; [trace.playwright.dev](https://trace.playwright.dev) 是一個 [progressive web application](https://web.dev/progressive-web-apps/)，在本地處理追蹤。

- Playwright Test 追蹤現在預設包含來源（這些可以用追蹤選項關閉）
- 追蹤檢視器現在顯示測試名稱
- 新的追蹤 Metadata 標籤包含瀏覽器詳細資訊
- 快照現在有 URL 欄



### HTML Report Update

- HTML 報告現在支援動態篩選
- 報告現在是一個**單一靜態 HTML 檔案**，可以通過電子郵件發送或作為 slack 附件。



### Ubuntu ARM64 支援 + 更多

- Playwright 現在支援 **Ubuntu 20.04 ARM64**。你現在可以在 Apple M1 和 Raspberry Pi 上的 Docker 中執行 Playwright 測試。
- 你現在可以使用 Playwright 在 Linux 上安裝穩定版本的 Edge：

  ```bash
  mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="install msedge"
  ```

### 新的 API

- Tracing 現在支援一個 [`'title'`](./api/class-tracing#tracing-start-option-title) 選項
- Page 導航支援一個新的 [`'commit'`](./api/class-page#page-goto) 等待選項

## Version 1.16

### 🎭 Playwright 函式庫

#### 定位器.waitFor

等待定位器解析為具有給定狀態的單個元素。預設為 `state: 'visible'`。

```java
Locator orderSent = page.locator("#order-sent");
orderSent.waitFor();
```

閱讀更多關於 [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for)。

### 🎭 Playwright Trace Viewer

- 使用 `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="show-trace"` 執行 trace viewer 並將 trace 檔案拖放到 trace viewer PWA
- 更好的動作目標視覺歸因

閱讀更多關於 [Trace Viewer](./trace-viewer) 的資訊。

### 瀏覽器版本

- Chromium 97.0.4666.0
- Mozilla Firefox 93.0
- WebKit 15.4

此版本的 Playwright 也針對以下穩定頻道進行了測試:

- Google Chrome 94
- Microsoft Edge 94

## 版本 1.15

### 🖱️ 滑鼠滾輪

使用 [Mouse.wheel()](/api/class-mouse.mdx#mouse-wheel) 現在可以垂直或水平滾動。

### 📜 新標頭 API

以前無法獲取回應的多個標頭值。現在這是可能的，並且有額外的輔助函式可用:

- [Request.allHeaders](https://ollama.com/api/class-request.mdx#request-all-headers)()
- [Request.headersArray](https://ollama.com/api/class-request.mdx#request-headers-array)()
- [Request.headerValue](https://ollama.com/api/class-request.mdx#request-header-value)()
- [Response.allHeaders](https://ollama.com/api/class-response.mdx#response-all-headers)()
- [Response.headersArray](https://ollama.com/api/class-response.mdx#response-headers-array)()
- [Response.headerValue](https://ollama.com/api/class-response.mdx#response-header-value)()
- [Response.headerValues](https://ollama.com/api/class-response.mdx#response-header-values)()

### 🌈 強制色彩模擬

現在可以透過在 [Browser.newContext()](/api/class-browser.mdx#browser-new-context) 中傳遞 `forced-colors` CSS 媒體功能或呼叫 [Page.emulateMedia()](/api/class-page.mdx#page-emulate-media) 來模擬它。

### 新的 API

- [Page.route()](/api/class-page.mdx#page-route) 接受新的 `times` 選項來指定此路由應匹配的次數。
- [Page.setChecked()](/api/class-page.mdx#page-set-checked) 和 [Locator.setChecked()](/api/class-locator.mdx#locator-set-checked) 被引入來設置複選框的選中狀態。
- [Request.sizes()](/api/class-request.mdx#request-sizes) 返回給定 http 請求的資源大小資訊。
- [Tracing.startChunk()](/api/class-tracing.mdx#tracing-start-chunk) - 開始新的追踪塊。
- [Tracing.stopChunk()](/api/class-tracing.mdx#tracing-stop-chunk) - 停止新的追踪塊。

### 瀏覽器版本

- Chromium 96.0.4641.0
- Mozilla Firefox 92.0
- WebKit 15.0

## Version 1.14

#### ⚡️ 新的 "strict" 模式

選擇器模糊性是自動化測試中的常見問題。**"strict" 模式**確保您的選擇器指向單一元素，否則會拋出錯誤。

在您的操作呼叫中設置 `setStrict(true)` 以選擇加入。

```java
// This will throw if you have more than one button!
page.click("button", new Page.ClickOptions().setStrict(true));
```

#### 📍 新的 [**定位器 API**](./api/class-locator)

Locator 代表頁面上元素的視圖。它捕捉了足夠的邏輯，以便在任何給定時刻檢索元素。

兩者之間的區別在於 [Locator](./api/class-locator) 和 [ElementHandle](./api/class-elementhandle) 是後者指向特定的元素，而 [Locator](./api/class-locator) 捕捉如何檢索該元素的邏輯。

另外，定位器預設是**「嚴格」的**！

```java
Locator locator = page.locator("button");
locator.click();
```

了解更多資訊請參閱[文件](./api/class-locator)。

#### 🧩 實驗性 [**React**](./other-locators.mdx#react-locator) 和 [**Vue**](./other-locators.mdx#vue-locator) 選擇器引擎

React 和 Vue 選擇器允許通過其元件名稱和/或屬性值選擇元素。語法與[屬性選擇器](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)非常相似，並支持所有屬性選擇器運算符。

```java
page.locator("_react=SubmitButton[enabled=true]").click();
page.locator("_vue=submit-button[enabled=true]").click();
```

了解更多在 [react selectors 文件](./other-locators.mdx#react-locator) 和 [vue selectors 文件](./other-locators.mdx#vue-locator)。

#### ✨ 新的 [**`nth`**](./other-locators.mdx#n-th-element-locator) 和 [**`visible`**](./other-locators.mdx#css-matching-only-visible-elements) 選擇器引擎

- [`nth`](./other-locators.mdx#n-th-element-locator) 選擇器引擎相當於 `:nth-match` 偽類別，但可以與其他選擇器引擎結合使用。
- [`visible`](./other-locators.mdx#css-matching-only-visible-elements) 選擇器引擎相當於 `:visible` 偽類別，但可以與其他選擇器引擎結合使用。

```java
// select the first button among all buttons
button.click("button >> nth=0");
// or if you are using locators, you can use first(), nth() and last()
page.locator("button").first().click();

// click a visible button
button.click("button >> visible=true");
```

### 瀏覽器版本

- Chromium 94.0.4595.0
- Mozilla Firefox 91.0
- WebKit 15.0

## 版本 1.13

#### Playwright

- **🖖 程式化拖放支援** 透過 [Page.dragAndDrop()](/api/class-page.mdx#page-drag-and-drop) API。
- **🔎 增強的 HAR** 包含請求和回應的 body 大小。透過 [Browser.newContext()](/api/class-browser.mdx#browser-new-context) 中的 `recordHar` 選項使用。

#### 工具

- Playwright Trace Viewer 現在顯示參數、返回值和 `console.log()` 呼叫。

#### 新的和全面修訂的指南

- [介紹](./intro.mdx)
- [身份驗證](./auth.mdx)

#### 瀏覽器版本

- Chromium 93.0.4576.0
- Mozilla Firefox 90.0
- WebKit 14.2

#### 新的 Playwright API

- 新的 `baseURL` 選項在 [Browser.newContext()](/api/class-browser.mdx#browser-new-context) 和 [Browser.newPage()](/api/class-browser.mdx#browser-new-page)
- [Response.securityDetails()](/api/class-response.mdx#response-security-details) 和 [Response.serverAddr()](/api/class-response.mdx#response-server-addr)
- [Page.dragAndDrop()](/api/class-page.mdx#page-drag-and-drop) 和 [Frame.dragAndDrop()](/api/class-frame.mdx#frame-drag-and-drop)
- [Download.cancel()](/api/class-download.mdx#download-cancel)
- [Page.inputValue()](/api/class-page.mdx#page-input-value), [Frame.inputValue()](/api/class-frame.mdx#frame-input-value) 和 [ElementHandle.inputValue()](/api/class-elementhandle.mdx#element-handle-input-value)
- 新的 `force` 選項在 [Page.fill()](/api/class-page.mdx#page-fill), [Frame.fill()](/api/class-frame.mdx#frame-fill), 和 [ElementHandle.fill()](/api/class-elementhandle.mdx#element-handle-fill)
- 新的 `force` 選項在 [Page.selectOption()](/api/class-page.mdx#page-select-option), [Frame.selectOption()](/api/class-frame.mdx#frame-select-option), 和 [ElementHandle.selectOption()](/api/class-elementhandle.mdx#element-handle-select-option)

## Version 1.12

#### 🧟‍♂️ 準備推出 Playwright Trace Viewer

[Playwright Trace Viewer](./trace-viewer.mdx) 是一個新的 GUI 工具，幫助在程式碼執行後探索記錄的 Playwright traces。Playwright traces 讓你檢查:

- 每個 Playwright 操作前後的頁面 DOM
- 每個 Playwright 操作前後的頁面渲染
- 腳本執行期間的瀏覽器網路

追蹤是使用新的 [BrowserContext.tracing()](/api/class-browsercontext.mdx#browser-context-tracing) API 記錄的:

```java
Browser browser = chromium.launch();
BrowserContext context = browser.newContext();

// Start tracing before creating / navigating a page.
context.tracing.start(new Tracing.StartOptions()
  .setScreenshots(true)
  .setSnapshots(true);

Page page = context.newPage();
page.goto("https://playwright.dev");

// Stop tracing and export it into a zip archive.
context.tracing.stop(new Tracing.StopOptions()
  .setPath(Paths.get("trace.zip")));
```

稍後使用 Playwright CLI 檢查追蹤:

```sh
mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="show-trace trace.zip"
```

這將開啟以下 GUI:



👉 閱讀更多在 [trace viewer documentation](./trace-viewer.mdx)。

#### 瀏覽器版本

- Chromium 93.0.4530.0
- Mozilla Firefox 89.0
- WebKit 14.2

此版本的 Playwright 也針對以下穩定頻道進行了測試:

- Google Chrome 91
- Microsoft Edge 91

#### 新的 API

- `reducedMotion` 選項在 [Page.emulateMedia()](/api/class-page.mdx#page-emulate-media), [BrowserType.launchPersistentContext()](/api/class-browsertype.mdx#browser-type-launch-persistent-context), [Browser.newContext()](/api/class-browser.mdx#browser-new-context) 和 [Browser.newPage()](/api/class-browser.mdx#browser-new-page)
- [BrowserContext.onRequest(handler)](/api/class-browsercontext.mdx#browser-context-event-request)
- [BrowserContext.onRequestFailed(handler)](/api/class-browsercontext.mdx#browser-context-event-request-failed)
- [BrowserContext.onRequestFinished(handler)](/api/class-browsercontext.mdx#browser-context-event-request-finished)
- [BrowserContext.onResponse(handler)](/api/class-browsercontext.mdx#browser-context-event-response)
- `tracesDir` 選項在 [BrowserType.launch()](/api/class-browsertype.mdx#browser-type-launch) 和 [BrowserType.launchPersistentContext()](/api/class-browsertype.mdx#browser-type-launch-persistent-context)
- 新的 [BrowserContext.tracing()](/api/class-browsercontext.mdx#browser-context-tracing) API 命名空間
- 新的 [Download.page()](/api/class-download.mdx#download-page) 方法

## Version 1.11

🎥 新 影片: [Playwright: A New Test Automation Framework for the Modern Web](https://youtu.be/_Jla6DyuEu4) ([slides](https://docs.google.com/presentation/d/1xFhZIJrdHkVe2CuMKOrni92HoG2SWslo0DhJJQMR1DI/edit?usp=sharing))

- 我們討論了 Playwright
- 展示了幕後的工程工作
- 進行了具有新功能的現場展示 ✨
- **特別感謝** [applitools](http://applitools.com/) 主辦這個活動並邀請我們！

#### 瀏覽器版本

- Chromium 92.0.4498.0
- Mozilla Firefox 89.0b6
- WebKit 14.2

#### 新的 API

- 支援 **非同步謂詞** 在 API 中的方法，如 [Page.waitForRequest](/api/class-page.mdx#page-wait-for-request) 和其他方法
- 新的 **模擬裝置**: Galaxy S8, Galaxy S9+, Galaxy Tab S4, Pixel 3, Pixel 4
- 新的方法:
  * [Page.waitForURL](/api/class-page.mdx#page-wait-for-url) 等待導航到 URL
  * [Video.delete](/api/class-video.mdx#video-delete) 和 [Video.saveAs](/api/class-video.mdx#video-save-as) 管理螢幕錄影
- 新的選項:
  * `screen` 選項在 [Browser.newContext](/api/class-browser.mdx#browser-new-context) 方法中模擬 `window.screen` 的尺寸
  * `position` 選項在 [Page.check](/api/class-page.mdx#page-check) 和 [Page.uncheck](/api/class-page.mdx#page-uncheck) 方法中
  * `trial` 選項在 [Page.check](/api/class-page.mdx#page-check), [Page.uncheck](/api/class-page.mdx#page-uncheck), [Page.click](/api/class-page.mdx#page-click), [Page.dblclick](/api/class-page.mdx#page-dblclick), [Page.hover](/api/class-page.mdx#page-hover) 和 [Page.tap](/api/class-page.mdx#page-tap) 方法中進行乾跑操作

## Version 1.10

- [Playwright for Java v1.10](https://github.com/microsoft/playwright-java) 現在已經**穩定**！
- 使用[新頻道 API](./browsers)在**Google Chrome**和**Microsoft Edge**穩定頻道上執行 Playwright。
- 在 Mac 和 Windows 上，Chromium 截圖**速度快**。

#### 捆綁的瀏覽器版本

- Chromium 90.0.4430.0
- Mozilla Firefox 87.0b10
- WebKit 14.2

此版本的 Playwright 也針對以下穩定頻道進行了測試:

- Google Chrome 89
- Microsoft Edge 89

#### 新的 API

- [BrowserType.launch()](https://ollama.com/library) 現在接受新的 'channel' 選項。更多資訊請參閱[我們的文件](./browsers)。

## Version 1.9

- [Playwright Inspector](./debug.mdx) 是一個**新的 GUI 工具**，用於編寫和調試你的測試。
  - **逐行調試**你的 Playwright 腳本，具有播放、暫停和逐步執行功能。
  - 通過**錄製用戶操作**來編寫新腳本。
  - 通過懸停在元素上來**生成元素選擇器**。
  - 設置 `PWDEBUG=1` 環境變量以啟動 Inspector
- 在有頭模式下使用 [Page.pause()](./api/class-page.mdx#page-pause) **暫停腳本執行**。暫停頁面會啟動 [Playwright Inspector](./debug.mdx) 進行調試。
- **新的 has-text 偽類**用於 CSS 選擇器。`:has-text("example")` 匹配包含 `"example"` 的任何元素，可能在子元素或後代元素內。查看[更多範例](./other-locators.mdx#css-matching-by-text)。
- **頁面對話框現在在執行期間自動關閉**，除非配置了 `dialog` 事件的監聽器。了解[更多資訊](./dialogs.mdx)。
- [Playwright for Python](https://github.com/microsoft/playwright-python) 現在**穩定**，具有慣用的蛇形命名法 API 和預構建的 [Docker 映像](./docker.mdx) 用於在 CI/CD 中運行測試。

#### 瀏覽器版本

- Chromium 90.0.4421.0
- Mozilla Firefox 86.0b10
- WebKit 14.1

#### 新的 API

- [Page.pause()](/api/class-page.mdx#page-pause)。

## 版本 1.8

- [根據佈局選擇元素](./other-locators.mdx#css-matching-elements-based-on-layout) 使用 `:left-of()`, `:right-of()`, `:above()` 和 `:below()`。
- Playwright 現在包含命令列介面，前稱 playwright-cli。

  ```bash
  mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="--help"
  ```

- [Page.selectOption()](/api/class-page.mdx#page-select-option) 現在會等待選項出現。
- 新的方法來[斷言元素狀態](./actionability#assertions)，如 [Page.isEditable()](/api/class-page.mdx#page-is-editable)。

#### 新的 API

- [ElementHandle.isChecked()](/api/class-elementhandle.mdx#element-handle-is-checked)。
- [ElementHandle.isDisabled()](/api/class-elementhandle.mdx#element-handle-is-disabled)。
- [ElementHandle.isEditable()](/api/class-elementhandle.mdx#element-handle-is-editable)。
- [ElementHandle.isEnabled()](/api/class-elementhandle.mdx#element-handle-is-enabled)。
- [ElementHandle.isHidden()](/api/class-elementhandle.mdx#element-handle-is-hidden)。
- [ElementHandle.isVisible()](/api/class-elementhandle.mdx#element-handle-is-visible)。
- [Page.isChecked()](/api/class-page.mdx#page-is-checked)。
- [Page.isDisabled()](/api/class-page.mdx#page-is-disabled)。
- [Page.isEditable()](/api/class-page.mdx#page-is-editable)。
- [Page.isEnabled()](/api/class-page.mdx#page-is-enabled)。
- [Page.isHidden()](/api/class-page.mdx#page-is-hidden)。
- [Page.isVisible()](/api/class-page.mdx#page-is-visible)。
- 新選項 `'editable'` 在 [ElementHandle.waitForElementState()](/api/class-elementhandle.mdx#element-handle-wait-for-element-state)。

#### 瀏覽器版本

- Chromium 90.0.4392.0
- Mozilla Firefox 85.0b5
- WebKit 14.1

## 版本 1.7

- **新 Java SDK**: [Playwright for Java](https://github.com/microsoft/playwright-java) 現在與 [JavaScript](https://github.com/microsoft/playwright)、[Python](https://github.com/microsoft/playwright-python) 和 [.NET bindings](https://github.com/microsoft/playwright-dotnet) 相當。
- **瀏覽器儲存 API**: 新的便利 API 用於儲存和加載瀏覽器儲存狀態（cookies、本地儲存），以簡化具有身份驗證的自動化場景。
- **新 CSS 選擇器**: 我們聽取了您對更靈活選擇器的反饋，並重新設計了選擇器的實現。Playwright 1.7 推出了[新的 CSS 擴展](./other-locators.mdx#css-locator)，並且很快會有更多更新。
- **新網站**: [playwright.dev](https://playwright.dev/) 的文件網站已更新，現在使用 [Docusaurus](https://v2.docusaurus.io/) 構建。
- **支持 Apple Silicon**: 用於 WebKit 和 Chromium 的 Playwright 瀏覽器二進制文件現在已為 Apple Silicon 構建。

#### 新的 API

- [BrowserContext.storageState()](https://api/class-browsercontext.mdx#browser-context-storage-state) 來獲取當前狀態以供日後重用。
- `storageState` 選項在 [Browser.newContext()](https://api/class-browser.mdx#browser-new-context) 和 [Browser.newPage()](https://api/class-browser.mdx#browser-new-page) 中用於設定瀏覽器上下文狀態。

#### 瀏覽器版本

- Chromium 89.0.4344.0
- Mozilla Firefox 84.0b9
- WebKit 14.1




[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/java/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.jammy]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.jammy "Dockerfile.jammy"
