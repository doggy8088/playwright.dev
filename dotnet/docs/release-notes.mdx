---
id: release-notes
title: "發行說明"
toc_max_heading_level: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';
import ProgressiveImage from '@theme/ProgressiveImage';

## 版本 1.55

### 錄製測試
- 自動 `ToBeVisibleAsync()` 斷言：Codegen 現在可以為常見的 UI 互動產生自動 `ToBeVisibleAsync()` 斷言。此功能可以在 Codegen 設定 UI 中啟用。

### 重大變更
- ⚠️ 已移除對 Chromium 擴充功能 manifest v2 的支援。

### 其他
- 新增對 Debian 13 "Trixie" 的支援。
- 新增對 Xunit v3 的支援，作為 [`Microsoft.Playwright.Xunit.v3`](https://www.nuget.org/packages/Microsoft.Playwright.Xunit.v3) 的一部分
- 新增對 MSTest v4 的支援，作為 [`Microsoft.Playwright.MSTest.v4`](https://www.nuget.org/packages/Microsoft.Playwright.MSTest.v4) 的一部分

### 瀏覽器版本
- Chromium 140.0.7339.16
- Mozilla Firefox 141.0
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 139
- Microsoft Edge 139

## 版本 1.54

### 重點
- 在 [BrowserContext.CookiesAsync()](/api/class-browsercontext.mdx#browser-context-cookies) 和 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies) 中新增 cookie 屬性 `PartitionKey`。此屬性允許儲存和還原分割的 cookies。請參閱 [CHIPS MDN 文章](https://developer.mozilla.org/en-US/docs/Web/Privacy/Guides/Privacy_sandbox/Partitioned_cookies) 以取得更多資訊。請注意，瀏覽器對 cookie 分割有不同的支援和預設值。
- 在多個指令中新增選項 `--user-data-dir`。您可以指定相同的使用者資料目錄來重複使用瀏覽狀態，例如驗證，在不同的會話之間。
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 codegen --user-data-dir=./user-data
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 open` 不再開啟測試錄製器。請改用 `pwsh bin/Debug/netX/playwright.ps1 codegen`。

### 瀏覽器版本
- Chromium 139.0.7258.5
- Mozilla Firefox 140.0.2
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 140
- Microsoft Edge 140

## 版本 1.53

### 追蹤檢視器和 HTML 報告器更新
- 追蹤檢視器中的新步驟：![新的追蹤檢視器步驟](https://github.com/user-attachments/assets/1963ff7d-4070-41be-a79b-4333176921a2)
- 新方法 [Locator.Describe()](/api/class-locator.mdx#locator-describe) 用於描述定位器。用於追蹤檢視器。
  
  ```csharp
  var button = Page.GetByTestId("btn-sub").Describe("Subscribe button");
  await button.ClickAsync();
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 install --list` 現在會列出所有已安裝的瀏覽器、版本和位置。

### 瀏覽器版本
- Chromium 138.0.7204.4
- Mozilla Firefox 139.0
- WebKit 18.5

此版本也對以下穩定頻道進行了測試：
- Google Chrome 137
- Microsoft Edge 137

## 版本 1.52

### 重點
- 新方法 [Expect(Locator).ToContainClassAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-class) 用於人體工學地斷言元素上的個別類別名稱。
  
  ```csharp
    await Expect(Page.GetByRole(AriaRole.Listitem, new() { Name = "Ship v1.52" })).ToContainClassAsync("done");
  ```
  
- [Aria Snapshots](./aria-snapshots.mdx) 獲得兩個新屬性：[`/children`](./aria-snapshots.mdx#strict-matching) 用於嚴格匹配和 `/url` 用於連結。
  
  ```csharp
  await Expect(locator).ToMatchAriaSnapshotAsync(@"
    - list
      - /children: equal
      - listitem: Feature A
      - listitem:
        - link ""Feature B"":
          - /url: ""https://playwright.dev""
  ");
  ```
  
### 其他
- [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 中的新選項 [MaxRedirects](/api/class-apirequest.mdx#api-request-new-context-選項-max-redirects) 用於控制重定向的最大次數。

### 重大變更
- 像 [Page.RouteAsync()](/api/class-page.mdx#page-route) 這樣的方法中的全域 URL 模式不再支援 `?` 和 `[]`。我們建議改用正規表達式。
- 方法 [Route.ContinueAsync()](/api/class-route.mdx#route-continue) 不再允許覆寫 `Cookie` 標頭。如果提供了 `Cookie` 標頭，它將被忽略，cookie 將從瀏覽器的 cookie 儲存中載入。要設定自訂 cookies，請使用 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies)。
- macOS 13 現已棄用，將不再接收 WebKit 更新。請升級到更新的 macOS 版本以繼續受益於最新的 WebKit 改進。

### 瀏覽器版本
- Chromium 136.0.7103.25
- Mozilla Firefox 137.0
- WebKit 18.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 135
- Microsoft Edge 135

## 版本 1.51

### 重點
* [BrowserContext.StorageStateAsync()](/api/class-browsercontext.mdx#browser-context-storage-state) 的新選項 [IndexedDB](/api/class-browsercontext.mdx#browser-context-storage-state-選項-indexed-db) 允許儲存和還原 IndexedDB 內容。當您的應用程式使用 [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 儲存驗證權杖時很有用，例如 Firebase Authentication。
  
  以下是遵循[驗證指南](./auth.mdx#reusing-signed-in-state)的範例：
  
  ```csharp
  // Save storage state into the file. Make sure to include IndexedDB.
  await context.StorageStateAsync(new()
  {
      Path = "../../../playwright/.auth/state.json",
      IndexedDB = true
  });
  
  // Create a new context with the saved storage state.
  var context = await browser.NewContextAsync(new()
  {
      StorageStatePath = "../../../playwright/.auth/state.json"
  });
  ```
  
* 新選項 [Visible](/api/class-locator.mdx#locator-filter-選項-visible) for [Locator.Filter()](/api/class-locator.mdx#locator-filter) allows matching only visible elements.
  
  ```csharp
  // Ignore invisible todo items.
  var todoItems = Page.GetByTestId("todo-item").Filter(new() { Visible = true });
  // Check there are exactly 3 visible ones.
  await Expect(todoItems).ToHaveCountAsync(3);
  ```
  
* 新選項 `Contrast` for methods [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media) and [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 允許 emulate the `prefers-contrast` media feature.
* 新選項 [FailOnStatusCode](/api/class-apirequest.mdx#api-request-new-context-選項-fail-on-status-code) 讓所有 fetch requests made through the [APIRequestContext] throw on response codes other than 2xx and 3xx.

### 瀏覽器版本
* Chromium 134.0.6998.35
* Mozilla Firefox 135.0
* WebKit 18.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 133
* Microsoft Edge 133

## 版本 1.50

### 支援 Xunit
* Support for xUnit 2.8+ via [Microsoft.Playwright.Xunit](https://www.nuget.org/packages/Microsoft.Playwright.Xunit). Follow our [Getting Started](./intro.mdx) guide to learn more.

### 其他
* Added 方法 [Expect(Locator).ToHaveAccessibleErrorMessageAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-error-message) to assert the Locator points to an element with a given [aria errormessage](https://w3c.github.io/aria/#aria-errormessage).

### UI 更新
* New button in Codegen for picking elements to produce aria snapshots.
* Additional details (such as keys pressed) are now displayed alongside action API calls in traces.
* 在追蹤中顯示 `canvas` 內容容易出錯。顯示功能現在預設停用，可透過 `Display canvas content` UI 設定啟用。
* `Call` and `Network` panels now display additional time information.

### 重大變更
* [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable) and [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) now throw if the target element is not `<input>`, `<select>`, or a number of other editable elements.

### 瀏覽器版本
* Chromium 133.0.6943.16
* Mozilla Firefox 134.0
* WebKit 18.2

此版本也對以下穩定頻道進行了測試：
* Google Chrome 132
* Microsoft Edge 132

## 版本 1.49

### Aria 快照

新斷言 [Expect(Locator).ToMatchAriaSnapshotAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-match-aria-snapshot) 透過與預期的可存取性樹狀結構（以 YAML 表示）進行比較來驗證頁面結構。

```csharp
await page.GotoAsync("https://playwright.dev");
await Expect(page.Locator("body")).ToMatchAriaSnapshotAsync(@"
  - banner:
    - heading /Playwright enables reliable/ [level=1]
    - link ""Get started""
    - link ""Star microsoft/playwright on GitHub""
  - main:
    - img ""Browsers (Chromium, Firefox, WebKit)""
    - heading ""Any browser • Any platform • One API""
");
```

您可以使用 [測試產生器](./codegen) 或呼叫 [Locator.AriaSnapshotAsync()](/api/class-locator.mdx#locator-aria-snapshot) 來產生此斷言。

在 [aria snapshots 指南](./aria-snapshots) 中了解更多。

### 追蹤群組

新方法 [Tracing.GroupAsync()](/api/class-tracing.mdx#tracing-group) allows you to visually group actions in the trace viewer.

```csharp
// All actions between GroupAsync and GroupEndAsync
// will be shown in the trace viewer as a group.
await Page.Context.Tracing.GroupAsync("Open Playwright.dev > API");
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "API" }).ClickAsync();
await Page.Context.Tracing.GroupEndAsync();
```

### Breaking: `chrome` 和 `msedge` 頻道切換到新的無頭模式

This change affects you if you're using one of the following channels in your `playwright.config.ts`:
- `chrome`, `chrome-dev`, `chrome-beta`, or `chrome-canary`
- `msedge`, `msedge-dev`, `msedge-beta`, or `msedge-canary`

更新到 Playwright v1.49 後，執行您的測試套件。如果仍然通過，您就可以繼續使用。如果不是，您可能需要更新您的快照，並調整一些關於 PDF 檢視器和擴充功能的測試程式碼。請參閱 [issue #33566](https://github.com/microsoft/playwright/issues/33566) 以取得更多詳細資訊。

### 嘗試新的 Chromium 無頭模式

You can opt into the new headless mode by using `'chromium'` channel. As [official Chrome documentation puts it](https://developer.chrome.com/blog/chrome-headless-shell):

> New Headless on the other hand is the real Chrome browser, and is thus more authentic, reliable, and offers more features. This makes it more suitable for high-accuracy end-to-end web app testing or browser extension testing.

請參閱 [issue #33566](https://github.com/microsoft/playwright/issues/33566) 以查看您可能遇到的破壞性變更清單以及有關 Chromium headless 的更多詳細資訊。如果您在選擇加入後看到任何問題，請提交 issue。

```xml title="runsettings.xml"
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <LaunchOptions>
      <Channel>chromium</Channel>
    </LaunchOptions>
  </Playwright>
</RunSettings>
```

```bash
dotnet test -- Playwright.BrowserName=chromium Playwright.LaunchOptions.Channel=chromium
```

### 其他
- There will be no more updates for WebKit on Ubuntu 20.04 and Debian 11. We recommend updating your OS to a later version.
- `<canvas>` elements inside a snapshot now draw a preview.

### 瀏覽器版本
- Chromium 131.0.6778.33
- Mozilla Firefox 132.0
- WebKit 18.2

此版本也對以下穩定頻道進行了測試：
- Google Chrome 130
- Microsoft Edge 130

## 版本 1.48

### WebSocket 路由

新方法s [Page.RouteWebSocketAsync()](/api/class-page.mdx#page-route-web-socket) and [BrowserContext.RouteWebSocketAsync()](/api/class-browsercontext.mdx#browser-context-route-web-socket) 允許 intercept, modify and mock WebSocket connections initiated in the page. Below is a simple example that mocks WebSocket communication by responding to a `"request"` with a `"response"`.

```csharp
await page.RouteWebSocketAsync("/ws", ws => {
  ws.OnMessage(frame => {
    if (frame.Text == "request")
      ws.Send("response");
  });
});
```

請參閱 [WebSocketRoute] 以取得更多詳細資訊。

### UI 更新
- New "copy" buttons for annotations and test location in the HTML report.
- Route 方法 calls like [Route.FulfillAsync()](/api/class-route.mdx#route-fulfill) are not shown in the report and trace viewer anymore. You can see which network requests were routed in the network tab instead.
- New "Copy as cURL" and "Copy as fetch" buttons for requests in the network tab.

### 其他
- 新方法 [Page.RequestGCAsync()](/api/class-page.mdx#page-request-gc) may help detect memory leaks.
- Requests made by [APIRequestContext] now record detailed timing and security information in the HAR.

### 瀏覽器版本
- Chromium 130.0.6723.19
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 129
- Microsoft Edge 129

## 版本 1.47

### 網路分頁改進

The Network tab in the trace viewer has several nice improvements:
- filtering by asset type and URL
- better display of query string parameters
- preview of font assets

![Network tab now has filters](https://github.com/user-attachments/assets/4bd1b67d-90bd-438b-a227-00b9e86872e2)

### 其他
- The `mcr.microsoft.com/playwright/dotnet:v1.47.0` now serves a Playwright image based on Ubuntu 24.04 Noble. To use the 22.04 jammy-based image, please use `mcr.microsoft.com/playwright/dotnet:v1.47.0-jammy` instead.
- The `:latest`/`:focal`/`:jammy` tag for Playwright Docker images is no longer being published. Pin to a specific version for better stability and reproducibility.
- TLS client certificates 現在可以 be passed from memory by passing [ClientCertificates.Cert](/api/class-browser.mdx#browser-new-context-選項-client-certificates) and [ClientCertificates.Key](/api/class-browser.mdx#browser-new-context-選項-client-certificates) as byte arrays instead of file paths.
- [NoWaitAfter](/api/class-locator.mdx#locator-select-選項-選項-no-wait-after) in [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) was deprecated.
- We've seen reports of WebGL in Webkit misbehaving on GitHub Actions `macos-13`. We recommend upgrading GitHub Actions to `macos-14`.

### 瀏覽器版本
- Chromium 129.0.6668.29
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 128
- Microsoft Edge 128

## 版本 1.46

### TLS Client Certificates

Playwright 現在允許提供用戶端憑證，以便伺服器可以根據 TLS 用戶端驗證的規定來驗證它們。

You can provide client certificates as a parameter of [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) and [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context). The following snippet sets up a client certificate for `https://example.com`:

```csharp
var context = await Browser.NewContextAsync(new() {
  ClientCertificates = [
    new() {
      Origin = "https://example.com",
      CertPath = "client-certificates/cert.pem",
      KeyPath = "client-certificates/key.pem",
    }
  ]
});
```

### 追蹤檢視器更新
- Content of text attachments is now rendered inline in the attachments pane.
- New setting to show/hide routing actions like [Route.ContinueAsync()](/api/class-route.mdx#route-continue).
- Request 方法 and status are shown in the network details tab.
- New button to copy source file location to clipboard.
- Metadata pane now displays the `BaseURL`.

### 其他
- New `maxRetries` 選項 in [ApiRequestContext.FetchAsync()](/api/class-apirequestcontext.mdx#api-request-context-fetch) which retries on the `ECONNRESET` network error.

### 瀏覽器版本
- Chromium 128.0.6613.18
- Mozilla Firefox 128.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 127
- Microsoft Edge 127

## 版本 1.45

### 時鐘

Utilizing the new [Clock] API 允許 manipulate and control time within tests to verify time-related behavior. This API covers many common scenarios, including:
* testing with predefined time;
* keeping consistent time and timers;
* monitoring inactivity;
* ticking through time manually.

```csharp
// Initialize clock with some time before the test time and let the page load naturally.
// `Date.now` will progress as the timers fire.
await Page.Clock.InstallAsync(new()
{
  TimeDate = new DateTime(2024, 2, 2, 8, 0, 0)
});
await Page.GotoAsync("http://localhost:3333");

// Pretend that the user closed the laptop lid and opened it again at 10am.
// Pause the time once reached that point.
await Page.Clock.PauseAtAsync(new DateTime(2024, 2, 2, 10, 0, 0));

// Assert the page state.
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:00:00 AM");

// Close the laptop lid again and open it at 10:30am.
await Page.Clock.FastForwardAsync("30:00");
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:30:00 AM");
```

請參閱 [時鐘指南](./clock.mdx) 以取得更多詳細資訊。

### 其他
- 方法 [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) 現在支援 uploading a directory for `<input type=file webkitdirectory>` elements.
  
  ```csharp
  await page.GetByLabel("Upload directory").SetInputFilesAsync("mydir");
  ```
  
- 多個方法（如 [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) or [Locator.PressAsync()](/api/class-locator.mdx#locator-press) 現在支援 a `ControlOrMeta` modifier key. 此鍵 對應到 `Meta` on macOS and 對應到 `Control` on Windows and Linux.
  
  ```csharp
  // Press the common keyboard shortcut Control+S or Meta+S to trigger a "Save" operation.
  await page.Keyboard.PressAsync("ControlOrMeta+S");
  ```
  
- 新屬性 `httpCredentials.send` in [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) that 允許 either always send the `Authorization` header or only send it in response to `401 Unauthorized`.
- Playwright 現在支援 Chromium, Firefox and WebKit on Ubuntu 24.04.
- v1.45 is the last release to receive WebKit update for macOS 12 Monterey. Please update macOS to keep using the latest WebKit.

### 瀏覽器版本
* Chromium 127.0.6533.5
* Mozilla Firefox 127.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 126
* Microsoft Edge 126

## 版本 1.44

### 新的 API

**Accessibility assertions**
- [Expect(Locator).ToHaveAccessibleNameAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name) checks if the element has the specified accessible name:
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleNameAsync("Submit");
  ```
  
- [Expect(Locator).ToHaveAccessibleDescriptionAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description) checks if the element has the specified accessible description:
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleDescriptionAsync("Upload a photo");
  ```
  
- [Expect(Locator).ToHaveRoleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-role) checks if the element has the specified ARIA role:
  
  ```csharp
  var locator = Page.GetByTestId("save-button");
  await Expect(locator).ToHaveRoleAsync(AriaRole.Button);
  ```
  
**Locator handler**
- After executing the handler added with [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler), Playwright 現在會 wait until the overlay that triggered the handler is not visible anymore. You can opt-out of this behavior with the new `NoWaitAfter` 選項.
- You can use new `Times` 選項 in [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) to specify maximum number of times the handler should be run.
- The handler in [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) now accepts the locator as argument.
- New [Page.RemoveLocatorHandlerAsync()](/api/class-page.mdx#page-remove-locator-handler) 方法 for removing previously added locator handlers.

```csharp
var locator = Page.GetByText("This interstitial covers the button");
await Page.AddLocatorHandlerAsync(locator, async (overlay) =>
{
    await overlay.Locator("#close").ClickAsync();
}, new() { Times = 3, NoWaitAfter = true });
// Run your tests that can be interrupted by the overlay.
// ...
await Page.RemoveLocatorHandlerAsync(locator);
```

**Miscellaneous options**
- 新方法 [FormData.Append()](/api/class-formdata.mdx#form-data-append) 允許 specify repeating fields with the same name in [`Multipart`](./api/class-apirequestcontext#api-request-context-fetch-選項-multipart) 選項 in `APIRequestContext.FetchAsync()`:
  
  ```csharp
  var formData = Context.APIRequest.CreateFormData();
  formData.Append("file", new FilePayload()
  {
      Name = "f1.js",
      MimeType = "text/javascript",
      Buffer = System.Text.Encoding.UTF8.GetBytes("var x = 2024;")
  });
  formData.Append("file", new FilePayload()
  {
      Name = "f2.txt",
      MimeType = "text/plain",
      Buffer = System.Text.Encoding.UTF8.GetBytes("hello")
  });
  var response = await Context.APIRequest.PostAsync("https://example.com/uploadFiles", new() { Multipart = formData });
  ```
  
- [Expect(Page).ToHaveURLAsync()](/api/class-pageassertions.mdx#page-assertions-to-have-url) 現在支援 `IgnoreCase` [選項](./api/class-pageassertions#page-assertions-to-have-url-選項-ignore-case).

### 瀏覽器版本
* Chromium 125.0.6422.14
* Mozilla Firefox 125.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 124
* Microsoft Edge 124

## 版本 1.43

### 新的 API
- 方法 [BrowserContext.ClearCookiesAsync()](/api/class-browsercontext.mdx#browser-context-clear-cookies) 現在支援 filters to remove only some cookies.
  
  ```csharp
  // Clear all cookies.
  await Context.ClearCookiesAsync();
  // New: clear cookies with a particular name.
  await Context.ClearCookiesAsync(new() { Name = "session-id" });
  // New: clear cookies for a particular domain.
  await Context.ClearCookiesAsync(new() { Domain = "my-origin.com" });
  ```
  
- 新屬性 [Locator.ContentFrame](/api/class-locator.mdx#locator-content-frame) converts a [Locator] object to a [FrameLocator]. This can be useful when you have a [Locator] object obtained somewhere, and later on would like to interact with the content inside the frame.
  
  ```csharp
  var locator = Page.Locator("iframe[name='embedded']");
  // ...
  var frameLocator = locator.ContentFrame;
  await frameLocator.GetByRole(AriaRole.Button).ClickAsync();
  ```
  
- 新屬性 [FrameLocator.Owner](/api/class-framelocator.mdx#frame-locator-owner) converts a [FrameLocator] object to a [Locator]. This can be useful when you have a [FrameLocator] object obtained somewhere, and later on would like to interact with the `iframe` element.
  
  ```csharp
  var frameLocator = page.FrameLocator("iframe[name='embedded']");
  // ...
  var locator = frameLocator.Owner;
  await Expect(locator).ToBeVisibleAsync();
  ```
  
### 瀏覽器版本
* Chromium 124.0.6367.8
* Mozilla Firefox 124.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 123
* Microsoft Edge 123

## 版本 1.42

### 新的定位器處理器

新方法 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) registers a callback that will be invoked when specified element becomes visible and may block Playwright actions. The callback can get rid of the overlay. Here is an example that closes a cookie dialog when it appears.

```csharp
// Setup the handler.
await Page.AddLocatorHandlerAsync(
    Page.GetByRole(AriaRole.Heading, new() { Name = "Hej! You are in control of your cookies." }),
    async () =>
    {
        await Page.GetByRole(AriaRole.Button, new() { Name = "Accept all" }).ClickAsync();
    });
// Write the test as usual.
await Page.GotoAsync("https://www.ikea.com/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Collection of blue and white" }).ClickAsync();
await Expect(Page.GetByRole(AriaRole.Heading, new() { Name = "Light and easy" })).ToBeVisibleAsync();
```

### 新的 API
- [Page.PdfAsync()](/api/class-page.mdx#page-pdf) accepts two new options [Tagged](/api/class-page.mdx#page-pdf-選項-tagged) and [Outline](/api/class-page.mdx#page-pdf-選項-outline).

### 公告
* ⚠️ Ubuntu 18 is not supported anymore.

### 瀏覽器版本
* Chromium 123.0.6312.4
* Mozilla Firefox 123.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 122
* Microsoft Edge 123

## 版本 1.41

### 新的 API
- 新方法 [Page.UnrouteAllAsync()](/api/class-page.mdx#page-unroute-all) removes all routes registered by [Page.RouteAsync()](/api/class-page.mdx#page-route) and [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har). Optionally 允許 wait for ongoing routes to finish, or ignore any errors from them.
- 新方法 [BrowserContext.UnrouteAllAsync()](/api/class-browsercontext.mdx#browser-context-unroute-all) removes all routes registered by [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) and [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har). Optionally 允許 wait for ongoing routes to finish, or ignore any errors from them.
- 新選項s [Style](/api/class-page.mdx#page-screenshot-選項-style) in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) and [Style](/api/class-locator.mdx#locator-screenshot-選項-style) in [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) to add custom CSS to the page before taking a screenshot.

### 瀏覽器版本
* Chromium 121.0.6167.57
* Mozilla Firefox 121.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 120
* Microsoft Edge 120

## 版本 1.40

### 測試產生器更新

![Playwright Test Generator](https://github.com/microsoft/playwright/assets/9881434/e8d67e2e-f36d-4301-8631-023948d3e190)

New tools to generate assertions:
- "Assert visibility" tool generates [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible).
- "Assert value" tool generates [Expect(Locator).ToHaveValueAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-value).
- "Assert text" tool generates [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text).

Here is an example of a generated test with assertions:

```csharp
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Get started" }).ClickAsync();
await Expect(Page.GetByLabel("Breadcrumbs").GetByRole(AriaRole.List)).ToContainTextAsync("Installation");
await Expect(Page.GetByLabel("Search")).ToBeVisibleAsync();
await Page.GetByLabel("Search").ClickAsync();
await Page.GetByPlaceholder("Search docs").FillAsync("locator");
await Expect(Page.GetByPlaceholder("Search docs")).ToHaveValueAsync("locator");
```

### 新的 API
- Options [Reason](/api/class-page.mdx#page-close-選項-reason) in [Page.CloseAsync()](/api/class-page.mdx#page-close), [Reason](/api/class-browsercontext.mdx#browser-context-close-選項-reason) in [BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close) and [Reason](/api/class-browser.mdx#browser-close-選項-reason) in [Browser.CloseAsync()](/api/class-browser.mdx#browser-close). Close reason is reported for all operations interrupted by the closure.
- 選項 [FirefoxUserPrefs](/api/class-browsertype.mdx#browser-type-launch-persistent-context-選項-firefox-user-prefs) in [BrowserType.LaunchPersistentContextAsync()](/api/class-browsertype.mdx#browser-type-launch-persistent-context).

### 其他變更
- Methods [Download.PathAsync()](/api/class-download.mdx#download-path) and [Download.CreateReadStreamAsync()](/api/class-download.mdx#download-create-read-stream) throw an error for failed and cancelled downloads.
- Playwright [docker image](./docker.mdx) now comes with .NET 8 (new LTS).

### 瀏覽器版本
* Chromium 120.0.6099.28
* Mozilla Firefox 119.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 119
* Microsoft Edge 119

## 版本 1.39

長青瀏覽器更新。

### 瀏覽器版本
* Chromium 119.0.6045.9
* Mozilla Firefox 118.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 118
* Microsoft Edge 118

## 版本 1.38

### 追蹤檢視器更新

![Playwright Trace Viewer](https://github.com/microsoft/playwright/assets/746130/0c41e20d-c54b-4600-8ca8-1cbb6393ddef)
1. Zoom into time range.
1. Network panel redesign.

### 新的 API
- [BrowserContext.WebError](/api/class-browsercontext.mdx#browser-context-event-web-error)
- [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially)

### 棄用
* The following methods were deprecated: [Page.TypeAsync()](/api/class-page.mdx#page-type), [Frame.TypeAsync()](/api/class-frame.mdx#frame-type), [Locator.TypeAsync()](/api/class-locator.mdx#locator-type) and [ElementHandle.TypeAsync()](/api/class-elementhandle.mdx#element-handle-type). Please use [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) instead which is much faster. Use [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially) only if there is a special keyboard handling on the page, and you need to press keys one-by-one.

### 瀏覽器版本
* Chromium 117.0.5938.62
* Mozilla Firefox 117.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 116
* Microsoft Edge 116

## 版本 1.37

### 📚 Debian 12 Bookworm Support

Playwright 現在支援 Debian 12 Bookworm on both x86_64 and arm64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux support looks like this:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11 | Debian 12 |
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ | ✅ |

### 瀏覽器版本
* Chromium 116.0.5845.82
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 115
* Microsoft Edge 115

## 版本 1.36

🏝️ Summer maintenance release.

### 瀏覽器版本
* Chromium 115.0.5790.75
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.35

### 重點
* 新選項 `MaskColor` for methods [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) and [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) to change default masking color.
* New `uninstall` CLI command to uninstall browser binaries:
  
  ```bash
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall # remove browsers installed by this installation
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall --all # remove all ever-install Playwright browsers
  ```
  
### 瀏覽器版本
* Chromium 115.0.5790.13
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.34

### 重點
* New [Locator.And()](/api/class-locator.mdx#locator-and) to create a locator that matches both locators.
  
  ```csharp
  var button = page.GetByRole(AriaRole.BUTTON).And(page.GetByTitle("Subscribe"));
  ```
  
* New events [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) and [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog) to subscribe to any dialogs and console messages from any page from the given browser context. Use the new methods [ConsoleMessage.Page](/api/class-consolemessage.mdx#console-message-page) and [Dialog.Page](/api/class-dialog.mdx#dialog-page) to pin-point event source.

### 瀏覽器版本
* Chromium 114.0.5735.26
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 113
* Microsoft Edge 113

## 版本 1.33

### 定位器更新
* Use [Locator.Or()](/api/class-locator.mdx#locator-or) to create a locator that matches either of the two locators. Consider a scenario where   you'd like to click on a "New email" button, but sometimes a security settings dialog shows up instead. In this case, you can wait for either a "New email" button, or a dialog and act accordingly:
  
  ```csharp
  var newEmail = Page.GetByRole(AriaRole.Button, new() { Name = "New email" });
  var dialog = Page.GetByText("Confirm security settings");
  await Expect(newEmail.Or(dialog)).ToBeVisibleAsync();
  if (await dialog.IsVisibleAsync())
    await Page.GetByRole(AriaRole.Button, new() { Name = "Dismiss" }).ClickAsync();
  await newEmail.ClickAsync();
  ```
  
* Use new options [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) and [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) in [Locator.Filter()](/api/class-locator.mdx#locator-filter) to find elements that **do not match** certain conditions.
  
  ```csharp
  var rowLocator = Page.Locator("tr");
  await rowLocator
      .Filter(new() { HasNotText = "text in column 1" })
      .Filter(new() { HasNot = Page.GetByRole(AriaRole.Button, new() { Name = "column 2 button" })})
      .ScreenshotAsync();
  ```
  
* Use new web-first assertion [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached) to ensure that the element is present in the page's DOM. Do not confuse with the [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible) that ensures that element is both attached & visible.

### 新的 API
- [Locator.Or()](/api/class-locator.mdx#locator-or)
- 新選項 [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- 新選項 [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached)
- 新選項 [Timeout](/api/class-route.mdx#route-fetch-選項-timeout) in [Route.FetchAsync()](/api/class-route.mdx#route-fetch)

### ⚠️ Breaking change
* The `mcr.microsoft.com/playwright/dotnet:v1.33.0` now serves a Playwright image based on Ubuntu Jammy. To use the focal-based image, please use `mcr.microsoft.com/playwright/dotnet:v1.33.0-focal` instead.

### 瀏覽器版本
* Chromium 113.0.5672.53
* Mozilla Firefox 112.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 112
* Microsoft Edge 112

## 版本 1.32

### 新的 API
- 新選項s [UpdateMode](/api/class-page.mdx#page-route-from-har-選項-update-mode) and [UpdateContent](/api/class-page.mdx#page-route-from-har-選項-update-content) in [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) and [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har).
- Chaining existing locator objects, see [locator docs](./locators.mdx#matching-inside-a-locator) for details.
- 新選項 [Name](/api/class-tracing.mdx#tracing-start-chunk-選項-name) in 方法 [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk).

### 瀏覽器版本
* Chromium 112.0.5615.29
* Mozilla Firefox 111.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 111
* Microsoft Edge 111

## 版本 1.31

### 新的 API
- New assertion [Expect(Locator).ToBeInViewportAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-in-viewport) ensures that locator points to an element that intersects viewport, according to the [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  
  // Make sure at least some part of element intersects viewport.
  await Expect(locator).ToBeInViewportAsync();
  
  // Make sure element is fully outside of viewport.
  await Expect(locator).Not.ToBeInViewportAsync();
  
  // Make sure that at least half of the element intersects viewport.
  await Expect(locator).ToBeInViewportAsync(new() { Ratio = 0.5 });
  ```
  
- 新方法s [BrowserContext.NewCDPSessionAsync()](/api/class-browsercontext.mdx#browser-context-new-cdp-session) and [Browser.NewBrowserCDPSessionAsync()](/api/class-browser.mdx#browser-new-browser-cdp-session) create a [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) session for the page and browser respectively.

### 其他
- DOM snapshots in trace viewer can be now opened in a separate window.
- 新選項 [MaxRedirects](/api/class-route.mdx#route-fetch-選項-max-redirects) for 方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch).
- Playwright 現在支援 Debian 11 arm64.
- Official [docker images](./docker.mdx) now include Node 18 instead of Node 16.

### 瀏覽器版本
* Chromium 111.0.5563.19
* Mozilla Firefox 109.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 110
* Microsoft Edge 110

## 版本 1.30

### 瀏覽器版本
* Chromium 110.0.5481.38
* Mozilla Firefox 108.0.2
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 109
* Microsoft Edge 109

## 版本 1.29

### 新的 API
- 新方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch) and new 選項 `Json` for [Route.FulfillAsync()](/api/class-route.mdx#route-fulfill):
  
  ```csharp
  await Page.RouteAsync("**/api/settings", async route => {
    // Fetch original settings.
    var response = await route.FetchAsync();
  
    // Force settings theme to a predefined value.
    var json = await response.JsonAsync<MyDataType>();
    json.Theme = "Solarized";
  
    // Fulfill with modified data.
    await route.FulfillAsync(new() {
      Json = json
    });
  });
  ```
  
- 新方法 [Locator.AllAsync()](/api/class-locator.mdx#locator-all) to iterate over all matching elements:
  
  ```csharp
  // Check all checkboxes!
  var checkboxes = Page.GetByRole(AriaRole.Checkbox);
  foreach (var checkbox in await checkboxes.AllAsync())
    await checkbox.CheckAsync();
  ```
  
- [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) matches now by value or label:
  
  ```html
  <select multiple>
    <選項 value="red">Red</選項>
    <選項 value="green">Green</選項>
    <選項 value="blue">Blue</選項>
  </select>
  ```
  
  ```csharp
  await element.SelectOptionAsync("Red");
  ```
  
### 瀏覽器版本
* Chromium 109.0.5414.46
* Mozilla Firefox 107.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 108
* Microsoft Edge 108

## 版本 1.28

### Playwright 工具
* **Live Locators in CodeGen.** Generate a locator for any element on the page using "Explore" tool.

![Locator Explorer](https://user-images.githubusercontent.com/9798949/202293757-2e3ec0ac-1feb-4d6f-9935-73e08658b76d.png)

### 新的 API
- [Locator.BlurAsync()](/api/class-locator.mdx#locator-blur)
- [Locator.ClearAsync()](/api/class-locator.mdx#locator-clear)

### 瀏覽器版本
* Chromium 108.0.5359.29
* Mozilla Firefox 106.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 107
* Microsoft Edge 107

## 版本 1.27

### 定位器

With these new APIs writing locators is a joy:
- [Page.GetByText()](/api/class-page.mdx#page-get-by-text) to locate by text content.
- [Page.GetByRole()](/api/class-page.mdx#page-get-by-role) to locate by [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
- [Page.GetByLabel()](/api/class-page.mdx#page-get-by-label) to locate a form control by associated label's text.
- [Page.GetByTestId()](/api/class-page.mdx#page-get-by-test-id) to locate an element based on its `data-testid` attribute (other attribute can be configured).
- [Page.GetByPlaceholder()](/api/class-page.mdx#page-get-by-placeholder) to locate an input by placeholder.
- [Page.GetByAltText()](/api/class-page.mdx#page-get-by-alt-text) to locate an element, usually image, by its text alternative.
- [Page.GetByTitle()](/api/class-page.mdx#page-get-by-title) to locate an element by its title.

```csharp
await page.GetByLabel("User Name").FillAsync("John");

await page.GetByLabel("Password").FillAsync("secret-password");

await page.GetByRole(AriaRole.Button, new() { NameString = "Sign in" }).ClickAsync();

await Expect(Page.GetByText("Welcome, John!")).ToBeVisibleAsync();
```

所有相同的方法在 [Locator]、[FrameLocator] 和 [Frame] 類別中也都可以使用。

### 其他重點
- As announced in v1.25, Ubuntu 18 will not be supported as of Dec 2022. In addition to that, there will be no WebKit updates on Ubuntu 18 starting from the next Playwright release.

### 行為變更
- [Expect(Locator).ToHaveAttributeAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute.
  
  ```csharp
  await Expect(Page.GetByRole(AriaRole.Button)).ToHaveAttributeAsync("disabled", "");
  ```
  
### 瀏覽器版本
* Chromium 107.0.5304.18
* Mozilla Firefox 105.0.1
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 106
* Microsoft Edge 106

## 版本 1.26

### 斷言
- 新選項 `Enabled` for [Expect(Locator).ToBeEnabledAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-enabled).
- [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) now pierces open shadow roots.
- 新選項 `Editable` for [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable).
- 新選項 `Visible` for [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible).
- [Expect(Response).ToBeOKAsync()](/api/class-apiresponseassertions.mdx#api-response-assertions-to-be-ok) 現在可用.

### 其他重點
- 新選項 `MaxRedirects` for [ApiRequestContext.GetAsync()](/api/class-apirequestcontext.mdx#api-request-context-get) and others to limit redirect count.
- Codegen 現在支援 MSTest and NUnit frameworks.
- ASP .NET is now supported.

### 行為變更

A bunch of Playwright APIs already support the `WaitUntil: WaitUntilState.DOMContentLoaded` 選項. For example:

```csharp
await Page.GotoAsync("https://playwright.dev", new() { WaitUntil = WaitUntilState.DOMContentLoaded });
```

在 1.26 之前，這將等待所有 iframe 觸發 `DOMContentLoaded` 事件。

為了與 Web 規範保持一致，`WaitUntilState.DOMContentLoaded` 值只等待目標框架觸發 `'DOMContentLoaded'` 事件。使用 `WaitUntil: WaitUntilState.Load` 來等待所有 iframe。

### 瀏覽器版本
* Chromium 106.0.5249.30
* Mozilla Firefox 104.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 105
* Microsoft Edge 105

## 版本 1.25

### New .runsettings file的支援

`Microsoft.Playwright.NUnit` and `Microsoft.Playwright.MSTest` 現在會 consider the `.runsettings` file and passed settings via the CLI when running end-to-end tests. See in the [documentation](./test-runners) for a full list of supported settings.

The following does now work:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <!-- Playwright -->
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <ExpectTimeout>5000</ExpectTimeout>
    <LaunchOptions>
      <Headless>true</Headless>
      <Channel>msedge</Channel>
    </LaunchOptions>
  </Playwright>
  <!-- General run configuration -->
  <RunConfiguration>
    <EnvironmentVariables>
      <!-- For debugging selectors, it's recommend to set the following environment variable -->
      <DEBUG>pw:api</DEBUG>
    </EnvironmentVariables>
  </RunConfiguration>
</RunSettings>
```

### 公告
* 🪦 This is the last release with macOS 10.15 support (deprecated as of 1.21).
* ⚠️ Ubuntu 18 is now deprecated and will not be supported as of Dec 2022.

### 瀏覽器版本
* Chromium 105.0.5195.19
* Mozilla Firefox 103.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 104
* Microsoft Edge 104

## 版本 1.24

<div className="embed-youtube">

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9F05o1shxcY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>

### 🐂 Debian 11 Bullseye Support

Playwright 現在支援 Debian 11 Bullseye on x86_64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux support looks like this:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ |

### 新的介紹文件

我們重寫了入門文件，使其更專注於端對端測試。請在 [playwright.dev](./intro) 查看。

## 版本 1.23

### API 測試

Playwright for .NET 1.23 introduces new [API Testing](./api/class-apirequestcontext) that lets you send requests to the server directly from .NET! Now you can:
- test your server API
- prepare server side state before visiting the web application in a test
- validate server side post-conditions after running some actions in the browser

To do a request on behalf of Playwright's Page, use **new [Page.APIRequest](/api/class-page.mdx#page-request) API**:

```csharp
// Do a GET request on behalf of page
var response = await Page.APIRequest.GetAsync("http://example.com/foo.json");
Console.WriteLine(response.Status);
Console.WriteLine(response.StatusText);
Console.WriteLine(response.Ok);
Console.WriteLine(response.Headers["Content-Type"]);
Console.WriteLine(await response.TextAsync());
Console.WriteLine((await response.JsonAsync())?.GetProperty("foo").GetString());
```

在我們的 [API 測試指南](./api-testing) 中了解更多。

### 網路重播

現在您可以將網路流量錄製到 HAR 檔案中，並在測試中重複使用此流量。

To record network into HAR file:

```bash
pwsh bin/Debug/netX/playwright.ps1 open --save-har=example.har --save-har-glob="**/api/**" https://example.com
```

Alternatively, you can record HAR programmatically:

```csharp
var context = await browser.NewContextAsync(new()
{
  RecordHarPath = harPath,
  RecordHarUrlFilterString = "**/api/**",
});

// ... Perform actions ...

// Close context to ensure HAR is saved to disk.
context.CloseAsync();
```

Use the new methods [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) or [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) to serve matching responses from the [HAR](http://www.softwareishard.com/blog/har-12-spec/) file:

```csharp
await context.RouteFromHARAsync("example.har");
```

在 [我們的文件](./mock.mdx#mocking-with-har-files) 中了解更多。

### 進階路由

您現在可以使用 [Route.FallbackAsync()](/api/class-route.mdx#route-fallback) 將路由延遲到其他處理程序。

Consider the following example:

```csharp
// Remove a header from all requests.
await page.RouteAsync("**/*", async route =>
{
    var headers = route.Request.Headers;
    headers.Remove("X-Secret");
    await route.ContinueAsync(new() { Headers = headers });
});

// Abort all images.
await page.RouteAsync("**/*", async route =>
{
    if (route.Request.ResourceType == "image")
    {
        await route.AbortAsync();
    }
    else
    {
        await route.FallbackAsync();
    }
});
```

請注意，新方法 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 也參與路由，並且可以被延遲到。

### Web-First 斷言更新
* 新方法 [Expect(Locator).ToHaveValuesAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-values) that asserts all selected values of `<select multiple>` element.
* Methods [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text) and [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) now accept `ignoreCase` 選項.

### 其他
* If there's a service worker that's in your way, you 現在可以 easily disable it with a new context 選項 `serviceWorkers`:
  
  ```csharp
  var context = await Browser.NewContextAsync(new()
  {
      ServiceWorkers = ServiceWorkerPolicy.Block
  });
  ```
  
* Using `.zip` path for `recordHar` context 選項 automatically zips the resulting HAR:
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har.zip" });
  ```
  
* If you intend to edit HAR by hand, consider using the `"minimal"` HAR recording mode that only records information that is essential for replaying:
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har", RecordHarMode = HarMode.Minimal });
  ```
  
* Playwright now runs on Ubuntu 22 amd64 and Ubuntu 22 arm64.
* Playwright for .NET 現在支援 **linux-arm64** and provides a **arm64 Ubuntu 20.04 Docker image** for it.

## 版本 1.22

### 重點
- Role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  Read more in [our documentation](./locators.mdx#locate-by-role).
- New [Locator.Filter()](/api/class-locator.mdx#locator-filter) API to filter an existing locator
  
  ```csharp
  var buttons = page.Locator("role=button");
  // ...
  var submitLocator = buttons.Filter(new() { HasText = "Sign up" });
  await submitLocator.ClickAsync();
  ```
  
## 版本 1.21

### 重點
- New role selectors that allow selecting elements by their [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  Read more in [our documentation](./locators.mdx#locate-by-role).
- New `scale` 選項 in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) for smaller sized screenshots.
- New `caret` 選項 in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 控制 text caret. Defaults to `"hide"`.
- We now ship a designated .NET docker image `mcr.microsoft.com/playwright/dotnet`. Read more in [our documentation](./docker).

### 行為變更
- Playwright 現在支援 large file uploads (100s of MBs) via [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) API.

### 瀏覽器版本
- Chromium 101.0.4951.26
- Mozilla Firefox 98.0.2
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 100
- Microsoft Edge 100

## 版本 1.20

### Web-First 斷言

Playwright for .NET 1.20 引入了 [Web-First 斷言](./test-assertions)。

Consider the following example:

```csharp
using System.Threading.Tasks;
using Microsoft.Playwright.NUnit;
using NUnit.Framework;

namespace PlaywrightTests;

[TestFixture]
public class ExampleTests : PageTest
{
    [Test]
    public async Task StatusBecomesSubmitted()
    {
        await Expect(Page.Locator(".status")).ToHaveTextAsync("Submitted");
    }
}
```

Playwright 將使用選擇器 `.status` 重新測試節點，直到取得的節點包含 `"Submitted"` 文字。它將重新取得節點並一再檢查，直到滿足條件或達到逾時為止。您可以將此逾時作為選項傳遞。

在 [我們的文件](./test-assertions) 中了解更多。

### 其他更新
- 新選項s for methods [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot), [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) and [ElementHandle.ScreenshotAsync()](/api/class-elementhandle.mdx#element-handle-screenshot):
  * 選項 `ScreenshotAnimations.Disabled` rewinds all CSS animations and transitions to a consistent state
  * 選項 `mask: Locator[]` masks given elements, overlaying them with pink `#FF00FF` boxes.
- [Locator.HighlightAsync()](/api/class-locator.mdx#locator-highlight) visually reveals element(s) for easier debugging.

### 公告
- v1.20 is the last release to receive WebKit update for macOS 10.15 Catalina. Please update macOS to keep using latest & greatest WebKit!

### 瀏覽器版本
- Chromium 101.0.4921.0
- Mozilla Firefox 97.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 99
- Microsoft Edge 99

## 版本 1.19

### 重點
- Locator 現在支援 a `has` 選項 that makes sure it contains another locator inside:
  
  ```csharp
  await Page.Locator("article", new() { Has = Page.Locator(".highlight") }).ClickAsync();
  ```
  
  Read more in [locator documentation](./api/class-locator#locator-locator)
- New [Locator.Page](/api/class-locator.mdx#locator-page)
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) and [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) now automatically hide blinking caret
- Playwright Codegen now generates locators and frame locators

### 瀏覽器版本
- Chromium 100.0.4863.0
- Mozilla Firefox 96.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 98
- Microsoft Edge 98

## 版本 1.18

### 定位器改進
- [Locator.DragToAsync()](/api/class-locator.mdx#locator-drag-to)
- Each locator 現在可以 be optionally filtered by the text it contains:
  
  ```csharp
  await Page.Locator("li", new() { HasTextString = "My Item" })
            .Locator("button").click();
  ```
  
  Read more in [locator documentation](./api/class-locator#locator-locator)

### 新的 API 與變更
- [`AcceptDownloads`](./api/class-browser#browser-new-context-選項-accept-downloads) 選項 now defaults to `true`.
- [`Sources`](./api/class-tracing#tracing-start-選項-sources) 選項 to embed sources into traces.

### 瀏覽器版本
- Chromium 99.0.4812.0
- Mozilla Firefox 95.0
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 97
- Microsoft Edge 97

## 版本 1.17

### 框架定位器

Playwright 1.17 引入了 [frame locators](./api/class-framelocator) - 頁面上 iframe 的定位器。Frame locators 擷取足夠的邏輯來取得 `iframe` 然後在該 iframe 中定位元素。Frame locators 預設為嚴格模式，將等待 `iframe` 出現，並可用於 Web-First 斷言。

![Graphics](https://user-images.githubusercontent.com/746130/142082759-2170db38-370d-43ec-8d41-5f9941f57d83.png)

Frame locators 可以使用 [Page.FrameLocator()](/api/class-page.mdx#page-frame-locator) 或 [Locator.FrameLocator()](/api/class-locator.mdx#locator-frame-locator) 方法建立。

```csharp
var locator = page.FrameLocator("#my-frame").Locator("text=Submit");
await locator.ClickAsync();
```

在 [我們的文件](./api/class-framelocator) 中了解更多。

### 追蹤檢視器更新

Playwright Trace Viewer 現在 **可在線上使用**，網址為 https://trace.playwright.dev！只需拖放您的 `trace.zip` 檔案即可檢查其內容。

> **NOTE**: trace files are not uploaded anywhere; [trace.playwright.dev](https://trace.playwright.dev) is a [progressive web application](https://web.dev/progressive-web-apps/) that processes traces locally.
- Playwright Test traces now include sources by default (these could be turned off with tracing 選項)
- Trace Viewer now shows test name
- New trace metadata tab with browser details
- Snapshots now have URL bar

![image](https://user-images.githubusercontent.com/746130/141877831-29e37cd1-e574-4bd9-aab5-b13a463bb4ae.png)

### HTML Report Update
- HTML report 現在支援 dynamic filtering
- Report is now a **single static HTML file** that could be sent by e-mail or as a slack attachment.

![image](https://user-images.githubusercontent.com/746130/141877402-e486643d-72c7-4db3-8844-ed2072c5d676.png)

### Ubuntu ARM64 支援與更多功能
- Playwright 現在支援 **Ubuntu 20.04 ARM64**. You 現在可以 run Playwright tests inside Docker on Apple M1 and on Raspberry Pi.
- You 現在可以 use Playwright to install stable version of Edge on Linux:
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 install msedge
  ```
  
### 新的 API
- Tracing 現在支援 a [`'title'`](./api/class-tracing#tracing-start-選項-title) 選項
- Page navigations support a new [`'commit'`](./api/class-page#page-goto) waiting 選項

## 版本 1.16

### 🎭 Playwright Library

#### Locator.WaitForAsync

Wait for a locator to resolve to a single element with a given state. Defaults to the `state: 'visible'`.

```csharp
var orderSent = page.Locator("#order-sent");
orderSent.WaitForAsync();
```

Read more about [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for).

### 🎭 Playwright Trace Viewer
- run trace viewer with `pwsh bin/Debug/netX/playwright.ps1 show-trace` and drop trace files to the trace viewer PWA
- better visual attribution of action targets

Read more about [Trace Viewer](./trace-viewer).

### 瀏覽器版本
- Chromium 97.0.4666.0
- Mozilla Firefox 93.0
- WebKit 15.4

This version of Playwright was also tested against the following stable channels:
- Google Chrome 94
- Microsoft Edge 94

## 版本 1.15

### 🖱️ Mouse Wheel

By using [Mouse.WheelAsync()](/api/class-mouse.mdx#mouse-wheel) you are now able to scroll vertically or horizontally.

### 📜 New Headers API

Previously it was not possible to get multiple header values of a response. This is now possible and additional helper functions are available:
- [Request.AllHeadersAsync()](/api/class-request.mdx#request-all-headers)
- [Request.HeadersArrayAsync()](/api/class-request.mdx#request-headers-array)
- [Request.HeaderValueAsync()](/api/class-request.mdx#request-header-value)
- [Response.AllHeadersAsync()](/api/class-response.mdx#response-all-headers)
- [Response.HeadersArrayAsync()](/api/class-response.mdx#response-headers-array)
- [Response.HeaderValueAsync()](/api/class-response.mdx#response-header-value)
- [Response.HeaderValuesAsync()](/api/class-response.mdx#response-header-values)

### 🌈 Forced-Colors emulation

Its now possible to emulate the `forced-colors` CSS media feature by passing it in the [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) or calling [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media).

### 新的 API
- [Page.RouteAsync()](/api/class-page.mdx#page-route) accepts new `times` 選項 to specify how many times this route should be matched.
- [Page.SetCheckedAsync()](/api/class-page.mdx#page-set-checked) and [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) were introduced to set the checked state of a checkbox.
- [Request.SizesAsync()](/api/class-request.mdx#request-sizes) 回傳 resource size information for given http request.
- [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk) - Start a new trace chunk.
- [Tracing.StopChunkAsync()](/api/class-tracing.mdx#tracing-stop-chunk) - Stops a new trace chunk.

### Important ⚠
* ⬆ .NET Core Apps 2.1 are **no longer** supported for our CLI tooling. As of August 31st, 2021, .NET Core 2.1 is no [longer supported](https://devblogs.microsoft.com/dotnet/net-core-2-1-will-reach-end-of-support-on-august-21-2021/) and will not receive any security updates. We've decided to move the CLI forward and require .NET Core 3.1 as a minimum.

### 瀏覽器版本
- Chromium 96.0.4641.0
- Mozilla Firefox 92.0
- WebKit 15.0

## 版本 1.14

#### ⚡️ New "strict" mode

Selector ambiguity is a common problem in automation testing. **"strict" mode** ensures that your selector points to a single element and throws otherwise.

Set `setStrict(true)` in your action calls to opt in.

```csharp
// This will throw if you have more than one button!
await page.Locator("button", new() { Strict = true });
```

#### 📍 New [**Locators API**](./api/class-locator)

Locator represents a view to the element(s) on the page. It captures the logic sufficient to retrieve the element at any given moment.

The difference between the [Locator](./api/class-locator) and [ElementHandle](./api/class-elementhandle) is that the latter points to a particular element, while [Locator](./api/class-locator) captures the logic of how to retrieve that element.

Also, locators are **"strict" by default**!

```csharp
var locator = page.Locator("button");
await locator.ClickAsync();
```

Learn more in the [documentation](./api/class-locator).

#### 🧩 Experimental [**React**](./other-locators.mdx#react-locator) and [**Vue**](./other-locators.mdx#vue-locator) selector engines

React and Vue selectors allow selecting elements by its component name and/or 屬性 values. The syntax is very similar to [attribute selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) and supports all attribute selector operators.

```csharp
await page.Locator("_react=SubmitButton[enabled=true]").ClickAsync();
await page.Locator("_vue=submit-button[enabled=true]").ClickAsync();
```

Learn more in the [react selectors documentation](./other-locators.mdx#react-locator) and the [vue selectors documentation](./other-locators.mdx#vue-locator).

#### ✨ New [**`nth`**](./other-locators.mdx#n-th-element-locator) and [**`visible`**](./other-locators.mdx#css-matching-only-visible-elements) selector engines
- [`nth`](./other-locators.mdx#n-th-element-locator) selector engine is equivalent to the `:nth-match` pseudo class, but could be combined with other selector engines.
- [`visible`](./other-locators.mdx#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.

```csharp
// select the first button among all buttons
await button.ClickAsync("button >> nth=0");
// or if you are using locators, you can use First, Nth() and Last
await page.Locator("button").First.ClickAsync();

// click a visible button
await button.ClickAsync("button >> visible=true");
```

### 瀏覽器版本
- Chromium 94.0.4595.0
- Mozilla Firefox 91.0
- WebKit 15.0

## 版本 1.13

#### Playwright
- **🖖 Programmatic drag-and-drop support** via the [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) API.
- **🔎 Enhanced HAR** with body sizes for requests and responses. Use via `recordHar` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context).

#### 工具
- Playwright Trace Viewer now shows parameters, returned values and `console.log()` calls.

#### 新增與重新編寫的指南
- [Intro](./intro.mdx)
- [Authentication](./auth.mdx)

#### 瀏覽器版本
- Chromium 93.0.4576.0
- Mozilla Firefox 90.0
- WebKit 14.2

#### 新的 Playwright API
- new `baseURL` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) and [Browser.NewPageAsync()](/api/class-browser.mdx#browser-new-page)
- [Response.SecurityDetailsAsync()](/api/class-response.mdx#response-security-details) and [Response.ServerAddrAsync()](/api/class-response.mdx#response-server-addr)
- [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) and [Frame.DragAndDropAsync()](/api/class-frame.mdx#frame-drag-and-drop)
- [Download.CancelAsync()](/api/class-download.mdx#download-cancel)
- [Page.InputValueAsync()](/api/class-page.mdx#page-input-value), [Frame.InputValueAsync()](/api/class-frame.mdx#frame-input-value) and [ElementHandle.InputValueAsync()](/api/class-elementhandle.mdx#element-handle-input-value)
- new `force` 選項 in [Page.FillAsync()](/api/class-page.mdx#page-fill), [Frame.FillAsync()](/api/class-frame.mdx#frame-fill), and [ElementHandle.FillAsync()](/api/class-elementhandle.mdx#element-handle-fill)
- new `force` 選項 in [Page.SelectOptionAsync()](/api/class-page.mdx#page-select-選項), [Frame.SelectOptionAsync()](/api/class-frame.mdx#frame-select-選項), and [ElementHandle.SelectOptionAsync()](/api/class-elementhandle.mdx#element-handle-select-選項)

## 版本 1.12

#### 重點
- Playwright for .NET v1.12 is now stable!
- Ships with the [codegen](./codegen.mdx) and [trace viewer](./trace-viewer.mdx) tools out-of-the-box

#### 瀏覽器版本
- Chromium 93.0.4530.0
- Mozilla Firefox 89.0
- WebKit 14.2

This version of Playwright was also tested against the following stable channels:
- Google Chrome 91
- Microsoft Edge 91


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
