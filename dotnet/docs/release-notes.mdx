---
id: release-notes
title: "發行說明"
toc_max_heading_level: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';
import ProgressiveImage from '@theme/ProgressiveImage';

## 版本 1.55

### 錄製測試
- 自動 `ToBeVisibleAsync()` 斷言：Codegen 現在可以為常見的 UI 互動產生自動 `ToBeVisibleAsync()` 斷言。此功能可以在 Codegen 設定 UI 中啟用。

### 重大變更
- ⚠️ 已移除對 Chromium 擴充功能 manifest v2 的支援。

### 其他
- 新增對 Debian 13 "Trixie" 的支援。
- 新增對 Xunit v3 的支援，作為 [`Microsoft.Playwright.Xunit.v3`](https://www.nuget.org/packages/Microsoft.Playwright.Xunit.v3) 的一部分
- 新增對 MSTest v4 的支援，作為 [`Microsoft.Playwright.MSTest.v4`](https://www.nuget.org/packages/Microsoft.Playwright.MSTest.v4) 的一部分

### 瀏覽器版本
- Chromium 140.0.7339.16
- Mozilla Firefox 141.0
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 139
- Microsoft Edge 139

## 版本 1.54

### 重點
- 在 [BrowserContext.CookiesAsync()](/api/class-browsercontext.mdx#browser-context-cookies) 和 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies) 中新增 cookie 屬性 `PartitionKey`。此屬性允許儲存和還原分割的 cookies。請參閱 [CHIPS MDN 文章](https://developer.mozilla.org/en-US/docs/Web/Privacy/Guides/Privacy_sandbox/Partitioned_cookies) 以取得更多資訊。請注意，瀏覽器對 cookie 分割有不同的支援和預設值。
- 在多個指令中新增選項 `--user-data-dir`。您可以指定相同的使用者資料目錄來重複使用瀏覽狀態，例如驗證，在不同的會話之間。
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 codegen --user-data-dir=./user-data
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 open` 不再開啟測試錄製器。請改用 `pwsh bin/Debug/netX/playwright.ps1 codegen`。

### 瀏覽器版本
- Chromium 139.0.7258.5
- Mozilla Firefox 140.0.2
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 140
- Microsoft Edge 140

## 版本 1.53

### 追蹤檢視器和 HTML 報告器更新
- 追蹤檢視器中的新步驟：![新的追蹤檢視器步驟](https://github.com/user-attachments/assets/1963ff7d-4070-41be-a79b-4333176921a2)
- 新方法 [Locator.Describe()](/api/class-locator.mdx#locator-describe) 用於描述定位器。用於追蹤檢視器。
  
  ```csharp
  var button = Page.GetByTestId("btn-sub").Describe("Subscribe button");
  await button.ClickAsync();
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 install --list` 現在會列出所有已安裝的瀏覽器、版本和位置。

### 瀏覽器版本
- Chromium 138.0.7204.4
- Mozilla Firefox 139.0
- WebKit 18.5

此版本也對以下穩定頻道進行了測試：
- Google Chrome 137
- Microsoft Edge 137

## 版本 1.52

### 重點
- 新方法 [Expect(Locator).ToContainClassAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-class) 用於人體工學地斷言元素上的個別類別名稱。
  
  ```csharp
    await Expect(Page.GetByRole(AriaRole.Listitem, new() { Name = "Ship v1.52" })).ToContainClassAsync("done");
  ```
  
- [Aria Snapshots](./aria-snapshots.mdx) 獲得兩個新屬性：[`/children`](./aria-snapshots.mdx#strict-matching) 用於嚴格匹配和 `/url` 用於連結。
  
  ```csharp
  await Expect(locator).ToMatchAriaSnapshotAsync(@"
    - list
      - /children: equal
      - listitem: Feature A
      - listitem:
        - link ""Feature B"":
          - /url: ""https://playwright.dev""
  ");
  ```
  
### 其他
- [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 中的新選項 [MaxRedirects](/api/class-apirequest.mdx#api-request-new-context-選項-max-redirects) 用於控制重定向的最大次數。

### 重大變更
- 像 [Page.RouteAsync()](/api/class-page.mdx#page-route) 這樣的方法中的全域 URL 模式不再支援 `?` 和 `[]`。我們建議改用正規表達式。
- 方法 [Route.ContinueAsync()](/api/class-route.mdx#route-continue) 不再允許覆寫 `Cookie` 標頭。如果提供了 `Cookie` 標頭，它將被忽略，cookie 將從瀏覽器的 cookie 儲存中載入。要設定自訂 cookies，請使用 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies)。
- macOS 13 現已棄用，將不再接收 WebKit 更新。請升級到更新的 macOS 版本以繼續受益於最新的 WebKit 改進。

### 瀏覽器版本
- Chromium 136.0.7103.25
- Mozilla Firefox 137.0
- WebKit 18.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 135
- Microsoft Edge 135

## 版本 1.51

### 重點
* [BrowserContext.StorageStateAsync()](/api/class-browsercontext.mdx#browser-context-storage-state) 的新選項 [IndexedDB](/api/class-browsercontext.mdx#browser-context-storage-state-選項-indexed-db) 允許儲存和還原 IndexedDB 內容。當您的應用程式使用 [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 儲存驗證權杖時很有用，例如 Firebase Authentication。
  
  以下是遵循[驗證指南](./auth.mdx#reusing-signed-in-state)的範例：
  
  ```csharp
  // Save storage state into the file. Make sure to include IndexedDB.
  await context.StorageStateAsync(new()
  {
      Path = "../../../playwright/.auth/state.json",
      IndexedDB = true
  });
  
  // Create a new context with the saved storage state.
  var context = await browser.NewContextAsync(new()
  {
      StorageStatePath = "../../../playwright/.auth/state.json"
  });
  ```
  
* 新選項 [Visible](/api/class-locator.mdx#locator-filter-選項-visible) 用於 [Locator.Filter()](/api/class-locator.mdx#locator-filter) 允許僅匹配可見元素。
  
  ```csharp
  // Ignore invisible todo items.
  var todoItems = Page.GetByTestId("todo-item").Filter(new() { Visible = true });
  // Check there are exactly 3 visible ones.
  await Expect(todoItems).ToHaveCountAsync(3);
  ```
  
* 新選項 `Contrast` 用於方法 [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media) 和 [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 允許模擬 `prefers-contrast` 媒體功能。
* 新選項 [FailOnStatusCode](/api/class-apirequest.mdx#api-request-new-context-選項-fail-on-status-code) 讓所有透過 [APIRequestContext] 發出的 fetch 請求在回應代碼不是 2xx 和 3xx 時拋出例外。

### 瀏覽器版本
* Chromium 134.0.6998.35
* Mozilla Firefox 135.0
* WebKit 18.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 133
* Microsoft Edge 133

## 版本 1.50

### 支援 Xunit
* 支援 xUnit 2.8+ via [Microsoft.Playwright.Xunit](https://www.nuget.org/packages/Microsoft.Playwright.Xunit). Follow our [Getting Started](./intro.mdx) guide to learn more.

### 其他
* Added 方法 [Expect(Locator).ToHaveAccessibleErrorMessageAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-error-message) to assert the Locator points to an element with a given [aria errormessage](https://w3c.github.io/aria/#aria-errormessage).

### UI 更新
* Codegen 中用於選擇元素以產生 aria 快照的新按鈕。
* 現在在追蹤中的動作 API 呼叫旁邊顯示額外的詳細資訊（例如按下的按鍵）。
* 在追蹤中顯示 `canvas` 內容容易出錯。顯示功能現在預設停用，可透過 `Display canvas content` UI 設定啟用。
* `Call` 和 `Network` 面板現在顯示額外的時間資訊。

### 重大變更
* [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable) 和 [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) now throw if the target element is not `<input>`, `<select>`, or a number of other editable elements.

### 瀏覽器版本
* Chromium 133.0.6943.16
* Mozilla Firefox 134.0
* WebKit 18.2

此版本也對以下穩定頻道進行了測試：
* Google Chrome 132
* Microsoft Edge 132

## 版本 1.49

### Aria 快照

新斷言 [Expect(Locator).ToMatchAriaSnapshotAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-match-aria-snapshot) 透過與預期的可存取性樹狀結構（以 YAML 表示）進行比較來驗證頁面結構。

```csharp
await page.GotoAsync("https://playwright.dev");
await Expect(page.Locator("body")).ToMatchAriaSnapshotAsync(@"
  - banner:
    - heading /Playwright enables reliable/ [level=1]
    - link ""Get started""
    - link ""Star microsoft/playwright on GitHub""
  - main:
    - img ""Browsers (Chromium, Firefox, WebKit)""
    - heading ""Any browser • Any platform • One API""
");
```

您可以使用 [測試產生器](./codegen) 或呼叫 [Locator.AriaSnapshotAsync()](/api/class-locator.mdx#locator-aria-snapshot) 來產生此斷言。

在 [aria snapshots 指南](./aria-snapshots) 中了解更多。

### 追蹤群組

新方法 [Tracing.GroupAsync()](/api/class-tracing.mdx#tracing-group) 允許您在追蹤檢視器中視覺化地群組動作。

```csharp
// All actions between GroupAsync and GroupEndAsync
// will be shown in the trace viewer as a group.
await Page.Context.Tracing.GroupAsync("Open Playwright.dev > API");
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "API" }).ClickAsync();
await Page.Context.Tracing.GroupEndAsync();
```

### Breaking: `chrome` 和 `msedge` 頻道切換到新的無頭模式

如果您在 `playwright.config.ts` 中使用以下任一通道，此變更會影響您：
- `chrome`、`chrome-dev`、`chrome-beta` 或 `chrome-canary`
- `msedge`、`msedge-dev`、`msedge-beta` 或 `msedge-canary`

更新到 Playwright v1.49 後，執行您的測試套件。如果仍然通過，您就可以繼續使用。如果不是，您可能需要更新您的快照，並調整一些關於 PDF 檢視器和擴充功能的測試程式碼。請參閱 [issue #33566](https://github.com/microsoft/playwright/issues/33566) 以取得更多詳細資訊。

### 嘗試新的 Chromium 無頭模式

您可以透過使用 `'chromium'` 頻道選擇新的無頭模式。如 [官方 Chrome 文件所述](https://developer.chrome.com/blog/chrome-headless-shell)：

> 另一方面，新的無頭模式是真正的 Chrome 瀏覽器，因此更真實、可靠，並提供更多功能。這使其更適合高精度的端到端網頁應用程式測試或瀏覽器擴充功能測試。

請參閱 [issue #33566](https://github.com/microsoft/playwright/issues/33566) 以查看您可能遇到的破壞性變更清單以及有關 Chromium headless 的更多詳細資訊。如果您在選擇加入後看到任何問題，請提交 issue。

```xml title="runsettings.xml"
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <LaunchOptions>
      <Channel>chromium</Channel>
    </LaunchOptions>
  </Playwright>
</RunSettings>
```

```bash
dotnet test -- Playwright.BrowserName=chromium Playwright.LaunchOptions.Channel=chromium
```

### 其他
- 將不再提供 WebKit 在 Ubuntu 20.04 和 Debian 11 上的更新。我們建議將您的作業系統更新到較新版本。
- 快照中的 `<canvas>` 元素現在會繪製預覽。

### 瀏覽器版本
- Chromium 131.0.6778.33
- Mozilla Firefox 132.0
- WebKit 18.2

此版本也對以下穩定頻道進行了測試：
- Google Chrome 130
- Microsoft Edge 130

## 版本 1.48

### WebSocket 路由

新方法 [Page.RouteWebSocketAsync()](/api/class-page.mdx#page-route-web-socket) 和 [BrowserContext.RouteWebSocketAsync()](/api/class-browsercontext.mdx#browser-context-route-web-socket) 允許攔截、修改和模擬頁面中發起的 WebSocket 連線。以下是一個簡單範例，透過回應 `"request"` 訊息來模擬 WebSocket 通訊並回傳 `"response"`。

```csharp
await page.RouteWebSocketAsync("/ws", ws => {
  ws.OnMessage(frame => {
    if (frame.Text == "request")
      ws.Send("response");
  });
});
```

請參閱 [WebSocketRoute] 以取得更多詳細資訊。

### UI 更新
- HTML 報告中新增用於註釋和測試位置的「複製」按鈕。
- 路由方法呼叫（如 [Route.FulfillAsync()](/api/class-route.mdx#route-fulfill)）不再顯示在報告和追蹤檢視器中。您可以在網路標籤中查看哪些網路請求被路由。
- 網路分頁中新增用於請求的「複製為 cURL」和「複製為 fetch」按鈕。

### 其他
- 新方法 [Page.RequestGCAsync()](/api/class-page.mdx#page-request-gc) may help detect memory leaks.
- [APIRequestContext] 發出的請求現在在 HAR 中記錄詳細的時間和安全資訊。

### 瀏覽器版本
- Chromium 130.0.6723.19
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 129
- Microsoft Edge 129

## 版本 1.47

### 網路分頁改進

追蹤檢視器中的網路索引標籤有幾項良好的改進：
- 按資產類型和 URL 篩選
- 更好地顯示查詢字串參數
- preview of font assets

![Network tab now has filters](https://github.com/user-attachments/assets/4bd1b67d-90bd-438b-a227-00b9e86872e2)

### 其他
- `mcr.microsoft.com/playwright/dotnet:v1.47.0` 現在提供基於 Ubuntu 24.04 Noble 的 Playwright 映像。若要使用基於 22.04 jammy 的映像，請改用 `mcr.microsoft.com/playwright/dotnet:v1.47.0-jammy`。
- Playwright Docker 映像的 `:latest`/`:focal`/`:jammy` 標籤不再發布。為了更好的穩定性和可重現性，請固定到特定版本。
- TLS 用戶端憑證現在可以透過傳遞 [ClientCertificates.Cert](/api/class-browser.mdx#browser-new-context-選項-client-certificates) 和 [ClientCertificates.Key](/api/class-browser.mdx#browser-new-context-選項-client-certificates) 作為位元組陣列而非檔案路徑從記憶體傳遞。
- [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) 中的 [NoWaitAfter](/api/class-locator.mdx#locator-select-選項-選項-no-wait-after) 已被棄用。
- 我們在 GitHub Actions `macos-13` 上看到了 Webkit 中 WebGL 的異常行為報告。我們建議將 GitHub Actions 升級到 `macos-14`。

### 瀏覽器版本
- Chromium 129.0.6668.29
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 128
- Microsoft Edge 128

## 版本 1.46

### TLS Client Certificates

Playwright 現在允許提供用戶端憑證，以便伺服器可以根據 TLS 用戶端驗證的規定來驗證它們。

您可以提供用戶端憑證作為 [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 和 [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 的參數。以下程式碼片段為 `https://example.com` 設定用戶端憑證：

```csharp
var context = await Browser.NewContextAsync(new() {
  ClientCertificates = [
    new() {
      Origin = "https://example.com",
      CertPath = "client-certificates/cert.pem",
      KeyPath = "client-certificates/key.pem",
    }
  ]
});
```

### 追蹤檢視器更新
- 文字附件的內容現在在附件窗格中以行內方式呈現。
- 顯示/隱藏路由動作（如 [Route.ContinueAsync()](/api/class-route.mdx#route-continue)）的新設定。
- 請求方法和狀態顯示在網路詳細資訊標籤中。
- 複製來源檔案位置到剪貼簿的新按鈕。
- 中繼資料窗格現在顯示 `BaseURL`。

### 其他
- [ApiRequestContext.FetchAsync()](/api/class-apirequestcontext.mdx#api-request-context-fetch) 中新的 `maxRetries` 選項，在 `ECONNRESET` 網路錯誤時重試。

### 瀏覽器版本
- Chromium 128.0.6613.18
- Mozilla Firefox 128.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 127
- Microsoft Edge 127

## 版本 1.45

### 時鐘

利用新的 [Clock] API 允許在測試中操控和控制時間，以驗證與時間相關的行為。此 API 涵蓋許多常見情境，包括：
* testing with predefined time;
* keeping consistent time and timers;
* monitoring inactivity;
* ticking through time manually.

```csharp
// Initialize clock with some time before the test time and let the page load naturally.
// `Date.now` will progress as the timers fire.
await Page.Clock.InstallAsync(new()
{
  TimeDate = new DateTime(2024, 2, 2, 8, 0, 0)
});
await Page.GotoAsync("http://localhost:3333");

// Pretend that the user closed the laptop lid and opened it again at 10am.
// Pause the time once reached that point.
await Page.Clock.PauseAtAsync(new DateTime(2024, 2, 2, 10, 0, 0));

// Assert the page state.
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:00:00 AM");

// Close the laptop lid again and open it at 10:30am.
await Page.Clock.FastForwardAsync("30:00");
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:30:00 AM");
```

請參閱 [時鐘指南](./clock.mdx) 以取得更多詳細資訊。

### 其他
- 方法 [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) 現在支援為 `<input type=file webkitdirectory>` 元素上傳目錄。
  
  ```csharp
  await page.GetByLabel("Upload directory").SetInputFilesAsync("mydir");
  ```
  
- 多個方法（如 [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) 或 [Locator.PressAsync()](/api/class-locator.mdx#locator-press)）現在支援 `ControlOrMeta` 修飾鍵。此鍵在 macOS 上對應到 `Meta`，在 Windows 和 Linux 上對應到 `Control`。
  
  ```csharp
  // Press the common keyboard shortcut Control+S or Meta+S to trigger a "Save" operation.
  await page.Keyboard.PressAsync("ControlOrMeta+S");
  ```
  
- 新屬性 `httpCredentials.send` 在 [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 中，允許永遠傳送 `Authorization` 標頭或僅在回應 `401 Unauthorized` 時傳送。
- Playwright 現在支援在 Ubuntu 24.04 上使用 Chromium、Firefox 和 WebKit。
- v1.45 是最後一個接收 macOS 12 Monterey WebKit 更新的版本。請更新 macOS 以繼續使用最新的 WebKit。

### 瀏覽器版本
* Chromium 127.0.6533.5
* Mozilla Firefox 127.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 126
* Microsoft Edge 126

## 版本 1.44

### 新的 API

**無障礙斷言**
- [Expect(Locator).ToHaveAccessibleNameAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name) 檢查元素是否具有指定的無障礙名稱：
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleNameAsync("Submit");
  ```
  
- [Expect(Locator).ToHaveAccessibleDescriptionAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description) 檢查元素是否具有指定的無障礙描述：
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleDescriptionAsync("Upload a photo");
  ```
  
- [Expect(Locator).ToHaveRoleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-role) 檢查元素是否具有指定的 ARIA 角色：
  
  ```csharp
  var locator = Page.GetByTestId("save-button");
  await Expect(locator).ToHaveRoleAsync(AriaRole.Button);
  ```
  
**定位器處理器**
- 執行使用 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 新增的處理器後，Playwright 現在會等待直到觸發處理器的覆蓋層不再可見。您可以使用新的 `NoWaitAfter` 選項來選擇退出此行為。
- 您可以在 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 中使用新的 `Times` 選項來指定處理器應執行的最大次數。
- [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 中的處理器現在接受定位器作為參數。
- 新的 [Page.RemoveLocatorHandlerAsync()](/api/class-page.mdx#page-remove-locator-handler) 方法，用於移除先前新增的定位器處理器。

```csharp
var locator = Page.GetByText("This interstitial covers the button");
await Page.AddLocatorHandlerAsync(locator, async (overlay) =>
{
    await overlay.Locator("#close").ClickAsync();
}, new() { Times = 3, NoWaitAfter = true });
// Run your tests that can be interrupted by the overlay.
// ...
await Page.RemoveLocatorHandlerAsync(locator);
```

**其他選項**
- 新方法 [FormData.Append()](/api/class-formdata.mdx#form-data-append) 允許在 `APIRequestContext.FetchAsync()` 的 [`Multipart`](./api/class-apirequestcontext#api-request-context-fetch-選項-multipart) 選項中指定具有相同名稱的重複欄位：
  
  ```csharp
  var formData = Context.APIRequest.CreateFormData();
  formData.Append("file", new FilePayload()
  {
      Name = "f1.js",
      MimeType = "text/javascript",
      Buffer = System.Text.Encoding.UTF8.GetBytes("var x = 2024;")
  });
  formData.Append("file", new FilePayload()
  {
      Name = "f2.txt",
      MimeType = "text/plain",
      Buffer = System.Text.Encoding.UTF8.GetBytes("hello")
  });
  var response = await Context.APIRequest.PostAsync("https://example.com/uploadFiles", new() { Multipart = formData });
  ```
  
- [Expect(Page).ToHaveURLAsync()](/api/class-pageassertions.mdx#page-assertions-to-have-url) 現在支援 `IgnoreCase` [選項](./api/class-pageassertions#page-assertions-to-have-url-選項-ignore-case).

### 瀏覽器版本
* Chromium 125.0.6422.14
* Mozilla Firefox 125.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 124
* Microsoft Edge 124

## 版本 1.43

### 新的 API
- 方法 [BrowserContext.ClearCookiesAsync()](/api/class-browsercontext.mdx#browser-context-clear-cookies) 現在支援篩選器，僅移除部分 cookies。
  
  ```csharp
  // Clear all cookies.
  await Context.ClearCookiesAsync();
  // New: clear cookies with a particular name.
  await Context.ClearCookiesAsync(new() { Name = "session-id" });
  // New: clear cookies for a particular domain.
  await Context.ClearCookiesAsync(new() { Domain = "my-origin.com" });
  ```
  
- 新屬性 [Locator.ContentFrame](/api/class-locator.mdx#locator-content-frame) 將 [Locator] 物件轉換為 [FrameLocator]。當您在某處取得 [Locator] 物件，稍後想要與框架內的內容互動時，這會很有用。
  
  ```csharp
  var locator = Page.Locator("iframe[name='embedded']");
  // ...
  var frameLocator = locator.ContentFrame;
  await frameLocator.GetByRole(AriaRole.Button).ClickAsync();
  ```
  
- 新屬性 [FrameLocator.Owner](/api/class-framelocator.mdx#frame-locator-owner) 將 [FrameLocator] 物件轉換為 [Locator]。當您在某處取得 [FrameLocator] 物件，稍後想要與 `iframe` 元素互動時，這會很有用。
  
  ```csharp
  var frameLocator = page.FrameLocator("iframe[name='embedded']");
  // ...
  var locator = frameLocator.Owner;
  await Expect(locator).ToBeVisibleAsync();
  ```
  
### 瀏覽器版本
* Chromium 124.0.6367.8
* Mozilla Firefox 124.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 123
* Microsoft Edge 123

## 版本 1.42

### 新的定位器處理器

新方法 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 註冊一個回呼函數，當指定元素變為可見且可能阻擋 Playwright 動作時會被調用。回呼函數可以移除覆蓋層。以下是一個當 cookie 對話框出現時關閉它的範例。

```csharp
// Setup the handler.
await Page.AddLocatorHandlerAsync(
    Page.GetByRole(AriaRole.Heading, new() { Name = "Hej! You are in control of your cookies." }),
    async () =>
    {
        await Page.GetByRole(AriaRole.Button, new() { Name = "Accept all" }).ClickAsync();
    });
// Write the test as usual.
await Page.GotoAsync("https://www.ikea.com/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Collection of blue and white" }).ClickAsync();
await Expect(Page.GetByRole(AriaRole.Heading, new() { Name = "Light and easy" })).ToBeVisibleAsync();
```

### 新的 API
- [Page.PdfAsync()](/api/class-page.mdx#page-pdf) 接受兩個新選項 [Tagged](/api/class-page.mdx#page-pdf-選項-tagged) 和 [Outline](/api/class-page.mdx#page-pdf-選項-outline)。

### 公告
* ⚠️ Ubuntu 18 is not supported anymore.

### 瀏覽器版本
* Chromium 123.0.6312.4
* Mozilla Firefox 123.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 122
* Microsoft Edge 123

## 版本 1.41

### 新的 API
- 新方法 [Page.UnrouteAllAsync()](/api/class-page.mdx#page-unroute-all) 移除所有由 [Page.RouteAsync()](/api/class-page.mdx#page-route) 和 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 註冊的路由。可選擇等待正在進行的路由完成，或忽略來自它們的任何錯誤。
- 新方法 [BrowserContext.UnrouteAllAsync()](/api/class-browsercontext.mdx#browser-context-unroute-all) 移除所有由 [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 註冊的路由。可選擇等待正在進行的路由完成，或忽略來自它們的任何錯誤。
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 中的新選項 [Style](/api/class-page.mdx#page-screenshot-選項-style) 和 [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) 中的 [Style](/api/class-locator.mdx#locator-screenshot-選項-style)，用於在執行螢幕截圖前新增自訂 CSS 到頁面。

### 瀏覽器版本
* Chromium 121.0.6167.57
* Mozilla Firefox 121.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 120
* Microsoft Edge 120

## 版本 1.40

### 測試產生器更新

![Playwright Test Generator](https://github.com/microsoft/playwright/assets/9881434/e8d67e2e-f36d-4301-8631-023948d3e190)

新的產生斷言工具：
- "Assert visibility" 工具產生 [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible)。
- "Assert value" 工具產生 [Expect(Locator).ToHaveValueAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-value)。
- "Assert text" 工具產生 [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text)。

Here is an example of a generated test with assertions:

```csharp
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Get started" }).ClickAsync();
await Expect(Page.GetByLabel("Breadcrumbs").GetByRole(AriaRole.List)).ToContainTextAsync("Installation");
await Expect(Page.GetByLabel("Search")).ToBeVisibleAsync();
await Page.GetByLabel("Search").ClickAsync();
await Page.GetByPlaceholder("Search docs").FillAsync("locator");
await Expect(Page.GetByPlaceholder("Search docs")).ToHaveValueAsync("locator");
```

### 新的 API
- [Page.CloseAsync()](/api/class-page.mdx#page-close) 中的選項 [Reason](/api/class-page.mdx#page-close-選項-reason)、[BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close) 中的 [Reason](/api/class-browsercontext.mdx#browser-context-close-選項-reason) 和 [Browser.CloseAsync()](/api/class-browser.mdx#browser-close) 中的 [Reason](/api/class-browser.mdx#browser-close-選項-reason)。關閉原因會報告所有因關閉而中斷的操作。
- [BrowserType.LaunchPersistentContextAsync()](/api/class-browsertype.mdx#browser-type-launch-persistent-context) 中的選項 [FirefoxUserPrefs](/api/class-browsertype.mdx#browser-type-launch-persistent-context-選項-firefox-user-prefs)。

### 其他變更
- 方法 [Download.PathAsync()](/api/class-download.mdx#download-path) 和 [Download.CreateReadStreamAsync()](/api/class-download.mdx#download-create-read-stream) 在失敗和取消的下載時會拋出錯誤。
- Playwright [docker image](./docker.mdx) 現在包含 .NET 8（新的 LTS）。

### 瀏覽器版本
* Chromium 120.0.6099.28
* Mozilla Firefox 119.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 119
* Microsoft Edge 119

## 版本 1.39

長青瀏覽器更新。

### 瀏覽器版本
* Chromium 119.0.6045.9
* Mozilla Firefox 118.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 118
* Microsoft Edge 118

## 版本 1.38

### 追蹤檢視器更新

![Playwright Trace Viewer](https://github.com/microsoft/playwright/assets/746130/0c41e20d-c54b-4600-8ca8-1cbb6393ddef)
1. Zoom into time range.
1. Network panel redesign.

### 新的 API
- [BrowserContext.WebError](/api/class-browsercontext.mdx#browser-context-event-web-error)
- [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially)

### 棄用
* The following methods were deprecated: [Page.TypeAsync()](/api/class-page.mdx#page-type), [Frame.TypeAsync()](/api/class-frame.mdx#frame-type), [Locator.TypeAsync()](/api/class-locator.mdx#locator-type) 和 [ElementHandle.TypeAsync()](/api/class-elementhandle.mdx#element-handle-type). Please use [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) instead which is much faster. Use [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially) only if there is a special keyboard handling on the page, and you need to press keys one-by-one.

### 瀏覽器版本
* Chromium 117.0.5938.62
* Mozilla Firefox 117.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 116
* Microsoft Edge 116

## 版本 1.37

### 📚 Debian 12 Bookworm Support

Playwright 現在支援 Debian 12 Bookworm on both x86_64 and arm64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux support looks like this:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11 | Debian 12 |
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ | ✅ |

### 瀏覽器版本
* Chromium 116.0.5845.82
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 115
* Microsoft Edge 115

## 版本 1.36

🏝️ Summer maintenance release.

### 瀏覽器版本
* Chromium 115.0.5790.75
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.35

### 重點
* 新選項 `MaskColor`用於方法[Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 和 [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) to change default masking color.
* New `uninstall` CLI command to uninstall browser binaries:
  
  ```bash
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall # remove browsers installed by this installation
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall --all # remove all ever-install Playwright browsers
  ```
  
### 瀏覽器版本
* Chromium 115.0.5790.13
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.34

### 重點
* New [Locator.And()](/api/class-locator.mdx#locator-and) to create a locator that matches both locators.
  
  ```csharp
  var button = page.GetByRole(AriaRole.BUTTON).And(page.GetByTitle("Subscribe"));
  ```
  
* 新事件 [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) 和 [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog) 用於訂閱來自指定瀏覽器上下文中任何頁面的對話框和控制台訊息。使用新方法 [ConsoleMessage.Page](/api/class-consolemessage.mdx#console-message-page) 和 [Dialog.Page](/api/class-dialog.mdx#dialog-page) 來精確定位事件來源。

### 瀏覽器版本
* Chromium 114.0.5735.26
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 113
* Microsoft Edge 113

## 版本 1.33

### 定位器更新
* 使用 [Locator.Or()](/api/class-locator.mdx#locator-or) 建立符合兩個定位器其中之一的定位器。考慮這樣的場景：您想要點選「New email」按鈕，但有時會出現安全設定對話框。在這種情況下，您可以等待「New email」按鈕或對話框，並相應地採取行動：
  
  ```csharp
  var newEmail = Page.GetByRole(AriaRole.Button, new() { Name = "New email" });
  var dialog = Page.GetByText("Confirm security settings");
  await Expect(newEmail.Or(dialog)).ToBeVisibleAsync();
  if (await dialog.IsVisibleAsync())
    await Page.GetByRole(AriaRole.Button, new() { Name = "Dismiss" }).ClickAsync();
  await newEmail.ClickAsync();
  ```
  
* Use new options [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) 和 [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) in [Locator.Filter()](/api/class-locator.mdx#locator-filter) to find elements that **do not match** certain conditions.
  
  ```csharp
  var rowLocator = Page.Locator("tr");
  await rowLocator
      .Filter(new() { HasNotText = "text in column 1" })
      .Filter(new() { HasNot = Page.GetByRole(AriaRole.Button, new() { Name = "column 2 button" })})
      .ScreenshotAsync();
  ```
  
* 使用新的 web-first 斷言 [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached) 確保元素存在於頁面的 DOM 中。不要與 [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible) 混淆，後者確保元素既已附加又可見。

### 新的 API
- [Locator.Or()](/api/class-locator.mdx#locator-or)
- 新選項 [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- 新選項 [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached)
- 新選項 [Timeout](/api/class-route.mdx#route-fetch-選項-timeout) in [Route.FetchAsync()](/api/class-route.mdx#route-fetch)

### ⚠️ Breaking change
* The `mcr.microsoft.com/playwright/dotnet:v1.33.0` now serves a Playwright image based on Ubuntu Jammy. To use the focal-based image, please use `mcr.microsoft.com/playwright/dotnet:v1.33.0-focal` instead.

### 瀏覽器版本
* Chromium 113.0.5672.53
* Mozilla Firefox 112.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 112
* Microsoft Edge 112

## 版本 1.32

### 新的 API
- 新選項s [UpdateMode](/api/class-page.mdx#page-route-from-har-選項-update-mode) 和 [UpdateContent](/api/class-page.mdx#page-route-from-har-選項-update-content) in [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har).
- Chaining existing locator objects, see [locator docs](./locators.mdx#matching-inside-a-locator) for details.
- 新選項 [Name](/api/class-tracing.mdx#tracing-start-chunk-選項-name) in 方法 [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk).

### 瀏覽器版本
* Chromium 112.0.5615.29
* Mozilla Firefox 111.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 111
* Microsoft Edge 111

## 版本 1.31

### 新的 API
- 新斷言 [Expect(Locator).ToBeInViewportAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-in-viewport) 確保定位器指向與視窗相交的元素，根據 [intersection observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)。
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  
  // Make sure at least some part of element intersects viewport.
  await Expect(locator).ToBeInViewportAsync();
  
  // Make sure element is fully outside of viewport.
  await Expect(locator).Not.ToBeInViewportAsync();
  
  // Make sure that at least half of the element intersects viewport.
  await Expect(locator).ToBeInViewportAsync(new() { Ratio = 0.5 });
  ```
  
- 新方法s [BrowserContext.NewCDPSessionAsync()](/api/class-browsercontext.mdx#browser-context-new-cdp-session) 和 [Browser.NewBrowserCDPSessionAsync()](/api/class-browser.mdx#browser-new-browser-cdp-session) create a [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) session for the page and browser respectively.

### 其他
- 追蹤檢視器中的 DOM 快照現在可以在單獨的視窗中開啟。
- 新選項 [MaxRedirects](/api/class-route.mdx#route-fetch-選項-max-redirects) 用於方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch).
- Playwright 現在支援 Debian 11 arm64.
- 官方 [docker images](./docker.mdx) 現在包含 Node 18 而非 Node 16。

### 瀏覽器版本
* Chromium 111.0.5563.19
* Mozilla Firefox 109.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 110
* Microsoft Edge 110

## 版本 1.30

### 瀏覽器版本
* Chromium 110.0.5481.38
* Mozilla Firefox 108.0.2
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 109
* Microsoft Edge 109

## 版本 1.29

### 新的 API
- 新方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch) 和新選項 `Json` 用於[Route.FulfillAsync()](/api/class-route.mdx#route-fulfill):
  
  ```csharp
  await Page.RouteAsync("**/api/settings", async route => {
    // Fetch original settings.
    var response = await route.FetchAsync();
  
    // Force settings theme to a predefined value.
    var json = await response.JsonAsync<MyDataType>();
    json.Theme = "Solarized";
  
    // Fulfill with modified data.
    await route.FulfillAsync(new() {
      Json = json
    });
  });
  ```
  
- 新方法 [Locator.AllAsync()](/api/class-locator.mdx#locator-all) to iterate over all matching elements:
  
  ```csharp
  // Check all checkboxes!
  var checkboxes = Page.GetByRole(AriaRole.Checkbox);
  foreach (var checkbox in await checkboxes.AllAsync())
    await checkbox.CheckAsync();
  ```
  
- [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) matches現在by value or label:
  
  ```html
  <select multiple>
    <選項 value="red">Red</選項>
    <選項 value="green">Green</選項>
    <選項 value="blue">Blue</選項>
  </select>
  ```
  
  ```csharp
  await element.SelectOptionAsync("Red");
  ```
  
### 瀏覽器版本
* Chromium 109.0.5414.46
* Mozilla Firefox 107.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 108
* Microsoft Edge 108

## 版本 1.28

### Playwright 工具
* **CodeGen 中的即時定位器。** 使用「探索」工具為頁面上的任何元素產生定位器。

![Locator Explorer](https://user-images.githubusercontent.com/9798949/202293757-2e3ec0ac-1feb-4d6f-9935-73e08658b76d.png)

### 新的 API
- [Locator.BlurAsync()](/api/class-locator.mdx#locator-blur)
- [Locator.ClearAsync()](/api/class-locator.mdx#locator-clear)

### 瀏覽器版本
* Chromium 108.0.5359.29
* Mozilla Firefox 106.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 107
* Microsoft Edge 107

## 版本 1.27

### 定位器

With these new APIs writing locators is a joy:
- [Page.GetByText()](/api/class-page.mdx#page-get-by-text)以定位by text content.
- [Page.GetByRole()](/api/class-page.mdx#page-get-by-role)以定位by [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
- [Page.GetByLabel()](/api/class-page.mdx#page-get-by-label)以定位a form control by associated label's text.
- [Page.GetByTestId()](/api/class-page.mdx#page-get-by-test-id) 以根據元素的 `data-testid` 屬性定位元素（可配置其他屬性）。
- [Page.GetByPlaceholder()](/api/class-page.mdx#page-get-by-placeholder)以定位an input by placeholder.
- [Page.GetByAltText()](/api/class-page.mdx#page-get-by-alt-text)以定位an element, usually image, by its text alternative.
- [Page.GetByTitle()](/api/class-page.mdx#page-get-by-title)以定位an element by its title.

```csharp
await page.GetByLabel("User Name").FillAsync("John");

await page.GetByLabel("Password").FillAsync("secret-password");

await page.GetByRole(AriaRole.Button, new() { NameString = "Sign in" }).ClickAsync();

await Expect(Page.GetByText("Welcome, John!")).ToBeVisibleAsync();
```

所有相同的方法在 [Locator]、[FrameLocator] 和 [Frame] 類別中也都可以使用。

### 其他重點
- As announced in v1.25, Ubuntu 18 will not be supported as of Dec 2022. In addition to that, there will be no WebKit updates on Ubuntu 18 starting from the next Playwright release.

### 行為變更
- [Expect(Locator).ToHaveAttributeAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute) with an empty value does not match missing attribute anymore. For example, the following snippet will succeed when `button` **does not** have a `disabled` attribute.
  
  ```csharp
  await Expect(Page.GetByRole(AriaRole.Button)).ToHaveAttributeAsync("disabled", "");
  ```
  
### 瀏覽器版本
* Chromium 107.0.5304.18
* Mozilla Firefox 105.0.1
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 106
* Microsoft Edge 106

## 版本 1.26

### 斷言
- 新選項 `Enabled` for [Expect(Locator).ToBeEnabledAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-enabled).
- [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text)現在pierces open shadow roots.
- 新選項 `Editable` for [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable).
- 新選項 `Visible` for [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible).
- [Expect(Response).ToBeOKAsync()](/api/class-apiresponseassertions.mdx#api-response-assertions-to-be-ok) 現在可用.

### 其他重點
- 新選項 `MaxRedirects` for [ApiRequestContext.GetAsync()](/api/class-apirequestcontext.mdx#api-request-context-get)和其他方法以limit redirect count.
- Codegen 現在支援 MSTest and NUnit frameworks.
- 現在支援 ASP .NET。

### 行為變更

A bunch of Playwright APIs already support the `WaitUntil: WaitUntilState.DOMContentLoaded` 選項. For example:

```csharp
await Page.GotoAsync("https://playwright.dev", new() { WaitUntil = WaitUntilState.DOMContentLoaded });
```

在 1.26 之前，這將等待所有 iframe 觸發 `DOMContentLoaded` 事件。

為了與 Web 規範保持一致，`WaitUntilState.DOMContentLoaded` 值只等待目標框架觸發 `'DOMContentLoaded'` 事件。使用 `WaitUntil: WaitUntilState.Load` 來等待所有 iframe。

### 瀏覽器版本
* Chromium 106.0.5249.30
* Mozilla Firefox 104.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 105
* Microsoft Edge 105

## 版本 1.25

### New .runsettings file的支援

`Microsoft.Playwright.NUnit` 和 `Microsoft.Playwright.MSTest` 現在會在執行端對端測試時考慮 `.runsettings` 檔案和透過 CLI 傳遞的設定。請參閱[文件](./test-runners)以取得支援設定的完整清單。

The following does now work:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <!-- Playwright -->
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <ExpectTimeout>5000</ExpectTimeout>
    <LaunchOptions>
      <Headless>true</Headless>
      <Channel>msedge</Channel>
    </LaunchOptions>
  </Playwright>
  <!-- General run configuration -->
  <RunConfiguration>
    <EnvironmentVariables>
      <!-- For debugging selectors, it's recommend以設定the following environment variable -->
      <DEBUG>pw:api</DEBUG>
    </EnvironmentVariables>
  </RunConfiguration>
</RunSettings>
```

### 公告
* 🪦 This is the last release with macOS 10.15 support (deprecated as of 1.21).
* ⚠️ Ubuntu 18 is now deprecated and will not be supported as of Dec 2022.

### 瀏覽器版本
* Chromium 105.0.5195.19
* Mozilla Firefox 103.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 104
* Microsoft Edge 104

## 版本 1.24

<div className="embed-youtube">

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9F05o1shxcY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>

### 🐂 Debian 11 Bullseye Support

Playwright 現在支援 Debian 11 Bullseye on x86_64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux support looks like this:

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ |

### 新的介紹文件

我們重寫了入門文件，使其更專注於端對端測試。請在 [playwright.dev](./intro) 查看。

## 版本 1.23

### API 測試

Playwright for .NET 1.23 引入新的 [API 測試](./api/class-apirequestcontext)，讓您可以直接從 .NET 向伺服器發送請求！現在您可以：
- test your server API
- prepare server side state before visiting the web application in a test
- validate server side post-conditions after running some actions in the browser

To do a request on behalf of Playwright's Page, use **new [Page.APIRequest](/api/class-page.mdx#page-request) API**:

```csharp
// Do a GET request on behalf of page
var response = await Page.APIRequest.GetAsync("http://example.com/foo.json");
Console.WriteLine(response.Status);
Console.WriteLine(response.StatusText);
Console.WriteLine(response.Ok);
Console.WriteLine(response.Headers["Content-Type"]);
Console.WriteLine(await response.TextAsync());
Console.WriteLine((await response.JsonAsync())?.GetProperty("foo").GetString());
```

在我們的 [API 測試指南](./api-testing) 中了解更多。

### 網路重播

現在您可以將網路流量錄製到 HAR 檔案中，並在測試中重複使用此流量。

To record network into HAR file:

```bash
pwsh bin/Debug/netX/playwright.ps1 open --save-har=example.har --save-har-glob="**/api/**" https://example.com
```

Alternatively, you can record HAR programmatically:

```csharp
var context = await browser.NewContextAsync(new()
{
  RecordHarPath = harPath,
  RecordHarUrlFilterString = "**/api/**",
});

// ... Perform actions ...

// Close context to ensure HAR is saved to disk.
context.CloseAsync();
```

使用新方法 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 或 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 來從 [HAR](http://www.softwareishard.com/blog/har-12-spec/) 檔案提供匹配的回應：

```csharp
await context.RouteFromHARAsync("example.har");
```

在 [我們的文件](./mock.mdx#mocking-with-har-files) 中了解更多。

### 進階路由

您現在可以使用 [Route.FallbackAsync()](/api/class-route.mdx#route-fallback) 將路由延遲到其他處理程序。

Consider the following example:

```csharp
// Remove a header from all requests.
await page.RouteAsync("**/*", async route =>
{
    var headers = route.Request.Headers;
    headers.Remove("X-Secret");
    await route.ContinueAsync(new() { Headers = headers });
});

// Abort all images.
await page.RouteAsync("**/*", async route =>
{
    if (route.Request.ResourceType == "image")
    {
        await route.AbortAsync();
    }
    else
    {
        await route.FallbackAsync();
    }
});
```

請注意，新方法 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 也參與路由，並且可以被延遲到。

### Web-First 斷言更新
* 新方法 [Expect(Locator).ToHaveValuesAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-values) that asserts all selected values of `<select multiple>` element.
* Methods [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text) 和 [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) now accept `ignoreCase` 選項.

### 其他
* If there's a service worker that's in your way, you 現在可以 easily disable it with a new context 選項 `serviceWorkers`:
  
  ```csharp
  var context = await Browser.NewContextAsync(new()
  {
      ServiceWorkers = ServiceWorkerPolicy.Block
  });
  ```
  
* Using `.zip` path for `recordHar` context 選項 automatically zips the resulting HAR:
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har.zip" });
  ```
  
* If you intend to edit HAR by hand, consider using the `"minimal"` HAR recording mode that only records information that is essential for replaying:
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har", RecordHarMode = HarMode.Minimal });
  ```
  
* Playwright 現在在 Ubuntu 22 amd64 和 Ubuntu 22 arm64 上執行。
* Playwright for .NET 現在支援 **linux-arm64** 並提供相應的 **arm64 Ubuntu 20.04 Docker 映像**。

## 版本 1.22

### 重點
- 角色選擇器，允許依據其 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和[無障礙名稱](https://w3c.github.io/accname/#dfn-accessible-name)選取元素。
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  Read more in [our documentation](./locators.mdx#locate-by-role).
- 新的 [Locator.Filter()](/api/class-locator.mdx#locator-filter) API to filter an existing locator
  
  ```csharp
  var buttons = page.Locator("role=button");
  // ...
  var submitLocator = buttons.Filter(new() { HasText = "Sign up" });
  await submitLocator.ClickAsync();
  ```
  
## 版本 1.21

### 重點
- 新的角色選擇器，允許依據其 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和[無障礙名稱](https://w3c.github.io/accname/#dfn-accessible-name)選取元素。
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  Read more in [our documentation](./locators.mdx#locate-by-role).
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 中新的 `scale` 選項，用於較小尺寸的螢幕截圖。
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 中新的 `caret` 選項，控制文字游標。預設為 `"hide"`。
- 我們現在提供專用的 .NET docker 映像 `mcr.microsoft.com/playwright/dotnet`。在[我們的文件](./docker)中閱讀更多。

### 行為變更
- Playwright 現在透過 [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) API 支援大型檔案上傳（數百 MB）。

### 瀏覽器版本
- Chromium 101.0.4951.26
- Mozilla Firefox 98.0.2
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 100
- Microsoft Edge 100

## 版本 1.20

### Web-First 斷言

Playwright for .NET 1.20 引入了 [Web-First 斷言](./test-assertions)。

Consider the following example:

```csharp
using System.Threading.Tasks;
using Microsoft.Playwright.NUnit;
using NUnit.Framework;

namespace PlaywrightTests;

[TestFixture]
public class ExampleTests : PageTest
{
    [Test]
    public async Task StatusBecomesSubmitted()
    {
        await Expect(Page.Locator(".status")).ToHaveTextAsync("Submitted");
    }
}
```

Playwright 將使用選擇器 `.status` 重新測試節點，直到取得的節點包含 `"Submitted"` 文字。它將重新取得節點並一再檢查，直到滿足條件或達到逾時為止。您可以將此逾時作為選項傳遞。

在 [我們的文件](./test-assertions) 中了解更多。

### 其他更新
- 新選項s用於方法[Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot), [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) 和 [ElementHandle.ScreenshotAsync()](/api/class-elementhandle.mdx#element-handle-screenshot):
  * 選項 `ScreenshotAnimations.Disabled` rewinds all CSS animations and transitions to a consistent state
  * 選項 `mask: Locator[]` masks given elements, overlaying them with pink `#FF00FF` boxes.
- [Locator.HighlightAsync()](/api/class-locator.mdx#locator-highlight)視覺化地顯示element(s)以便更輕鬆地debugging.

### 公告
- v1.20是最後一個接收receive WebKit update for macOS 10.15 Catalina. 請更新macOS以繼續使用latest & greatest WebKit!

### 瀏覽器版本
- Chromium 101.0.4921.0
- Mozilla Firefox 97.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 99
- Microsoft Edge 99

## 版本 1.19

### 重點
- Locator 現在支援 `has` 選項，確保它在內部包含另一個 locator：
  
  ```csharp
  await Page.Locator("article", new() { Has = Page.Locator(".highlight") }).ClickAsync();
  ```
  
  Read more in [locator documentation](./api/class-locator#locator-locator)
- New [Locator.Page](/api/class-locator.mdx#locator-page)
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 和 [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot)現在automatically hide blinking caret
- Playwright Codegen 現在會產生定位器和框架定位器

### 瀏覽器版本
- Chromium 100.0.4863.0
- Mozilla Firefox 96.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 98
- Microsoft Edge 98

## 版本 1.18

### 定位器改進
- [Locator.DragToAsync()](/api/class-locator.mdx#locator-drag-to)
- 每個定位器現在可以選擇性地依據其包含的文字進行篩選：
  
  ```csharp
  await Page.Locator("li", new() { HasTextString = "My Item" })
            .Locator("button").click();
  ```
  
  Read more in [locator documentation](./api/class-locator#locator-locator)

### 新的 API 與變更
- [`AcceptDownloads`](./api/class-browser#browser-new-context-選項-accept-downloads) 選項現在defaults to `true`.
- [`Sources`](./api/class-tracing#tracing-start-選項-sources) 選項 to embed sources into traces.

### 瀏覽器版本
- Chromium 99.0.4812.0
- Mozilla Firefox 95.0
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 97
- Microsoft Edge 97

## 版本 1.17

### 框架定位器

Playwright 1.17 引入了 [frame locators](./api/class-framelocator) - 頁面上 iframe 的定位器。Frame locators 擷取足夠的邏輯來取得 `iframe` 然後在該 iframe 中定位元素。Frame locators 預設為嚴格模式，將等待 `iframe` 出現，並可用於 Web-First 斷言。

![Graphics](https://user-images.githubusercontent.com/746130/142082759-2170db38-370d-43ec-8d41-5f9941f57d83.png)

Frame locators 可以使用 [Page.FrameLocator()](/api/class-page.mdx#page-frame-locator) 或 [Locator.FrameLocator()](/api/class-locator.mdx#locator-frame-locator) 方法建立。

```csharp
var locator = page.FrameLocator("#my-frame").Locator("text=Submit");
await locator.ClickAsync();
```

在 [我們的文件](./api/class-framelocator) 中了解更多。

### 追蹤檢視器更新

Playwright Trace Viewer 現在 **可在線上使用**，網址為 https://trace.playwright.dev！只需拖放您的 `trace.zip` 檔案即可檢查其內容。

> **NOTE**: trace files are not uploaded anywhere; [trace.playwright.dev](https://trace.playwright.dev) is a [progressive web application](https://web.dev/progressive-web-apps/) that processes traces locally.
- Playwright Test 追蹤現在預設包含來源（這些可以透過追蹤選項關閉）
- 追蹤檢視器現在顯示測試名稱
- 含有瀏覽器詳細資訊的新追蹤中繼資料標籤
- 快照現在具有 URL 列

![image](https://user-images.githubusercontent.com/746130/141877831-29e37cd1-e574-4bd9-aab5-b13a463bb4ae.png)

### HTML Report Update
- HTML report 現在支援 dynamic filtering
- 報告現在是**單一靜態 HTML 檔案**，可以透過電子郵件或作為 slack 附件發送。

![image](https://user-images.githubusercontent.com/746130/141877402-e486643d-72c7-4db3-8844-ed2072c5d676.png)

### Ubuntu ARM64 支援與更多功能
- Playwright 現在支援 **Ubuntu 20.04 ARM64**. You 現在可以 run Playwright tests inside Docker on Apple M1 and on Raspberry Pi.
- You 現在可以 use Playwright to install stable version of Edge on Linux:
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 install msedge
  ```
  
### 新的 API
- Tracing 現在支援 a [`'title'`](./api/class-tracing#tracing-start-選項-title) 選項
- 頁面導覽支援新的 [`'commit'`](./api/class-page#page-goto) 等待選項

## 版本 1.16

### 🎭 Playwright Library

#### Locator.WaitForAsync

Wait for a locator to resolve to a single element with a given state. Defaults to the `state: 'visible'`.

```csharp
var orderSent = page.Locator("#order-sent");
orderSent.WaitForAsync();
```

Read more about [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for).

### 🎭 Playwright Trace Viewer
- run trace viewer with `pwsh bin/Debug/netX/playwright.ps1 show-trace` and drop trace files to the trace viewer PWA
- better visual attribution of action targets

Read more about [Trace Viewer](./trace-viewer).

### 瀏覽器版本
- Chromium 97.0.4666.0
- Mozilla Firefox 93.0
- WebKit 15.4

This version of Playwright was also tested against the following stable channels:
- Google Chrome 94
- Microsoft Edge 94

## 版本 1.15

### 🖱️ Mouse Wheel

By using [Mouse.WheelAsync()](/api/class-mouse.mdx#mouse-wheel) you are now able to scroll vertically or horizontally.

### 📜 新的 Headers API

Previously it was not possible to get multiple header values of a response. This is now possible and additional helper functions are available:
- [Request.AllHeadersAsync()](/api/class-request.mdx#request-all-headers)
- [Request.HeadersArrayAsync()](/api/class-request.mdx#request-headers-array)
- [Request.HeaderValueAsync()](/api/class-request.mdx#request-header-value)
- [Response.AllHeadersAsync()](/api/class-response.mdx#response-all-headers)
- [Response.HeadersArrayAsync()](/api/class-response.mdx#response-headers-array)
- [Response.HeaderValueAsync()](/api/class-response.mdx#response-header-value)
- [Response.HeaderValuesAsync()](/api/class-response.mdx#response-header-values)

### 🌈 Forced-Colors emulation

Its now possible to emulate the `forced-colors` CSS media feature by passing it in the [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) or calling [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media).

### 新的 API
- [Page.RouteAsync()](/api/class-page.mdx#page-route) 接受新的 `times` 選項來指定此路由應匹配多少次。
- [Page.SetCheckedAsync()](/api/class-page.mdx#page-set-checked) 和 [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) 被引入以設定the checked state of a checkbox.
- [Request.SizesAsync()](/api/class-request.mdx#request-sizes) 回傳 resource size information for given http request.
- [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk) - Start a new trace chunk.
- [Tracing.StopChunkAsync()](/api/class-tracing.mdx#tracing-stop-chunk) - Stops a new trace chunk.

### Important ⚠
* ⬆ .NET Core Apps 2.1 are **no longer** supported for our CLI tooling. As of August 31st, 2021, .NET Core 2.1 is no [longer supported](https://devblogs.microsoft.com/dotnet/net-core-2-1-will-reach-end-of-support-on-august-21-2021/) and will not receive any security updates. We've decided to move the CLI forward and require .NET Core 3.1 as a minimum.

### 瀏覽器版本
- Chromium 96.0.4641.0
- Mozilla Firefox 92.0
- WebKit 15.0

## 版本 1.14

#### ⚡️ New "strict" mode

選擇器模糊性是自動化測試中的常見問題。**「嚴格」模式**確保您的選擇器指向單一元素，否則會拋出例外。

在您的動作呼叫中設定 `setStrict(true)` 以啟用。

```csharp
// This will throw if you have more than one button!
await page.Locator("button", new() { Strict = true });
```

#### 📍 新的 [**Locators API**](./api/class-locator)

Locator represents a view to the element(s) on the page. It captures the logic sufficient to retrieve the element at any given moment.

The difference between the [Locator](./api/class-locator) 和 [ElementHandle](./api/class-elementhandle) is that the latter points to a particular element, while [Locator](./api/class-locator) captures the logic of how to retrieve that element.

Also, locators are **"strict" by default**!

```csharp
var locator = page.Locator("button");
await locator.ClickAsync();
```

Learn more in the [documentation](./api/class-locator).

#### 🧩 Experimental [**React**](./other-locators.mdx#react-locator) 和 [**Vue**](./other-locators.mdx#vue-locator) selector engines

React 和 Vue 選擇器允許按組件名稱和/或屬性值選擇元素。語法與[屬性選擇器](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)非常相似，並支援所有屬性選擇器運算子。

```csharp
await page.Locator("_react=SubmitButton[enabled=true]").ClickAsync();
await page.Locator("_vue=submit-button[enabled=true]").ClickAsync();
```

Learn more in the [react selectors documentation](./other-locators.mdx#react-locator) and the [vue selectors documentation](./other-locators.mdx#vue-locator).

#### ✨ New [**`nth`**](./other-locators.mdx#n-th-element-locator) 和 [**`visible`**](./other-locators.mdx#css-matching-only-visible-elements) selector engines
- [`nth`](./other-locators.mdx#n-th-element-locator) selector engine is equivalent to the `:nth-match` pseudo class, but could be combined with other selector engines.
- [`visible`](./other-locators.mdx#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.

```csharp
// select the first button among all buttons
await button.ClickAsync("button >> nth=0");
// or if you are using locators, you can use First, Nth() and Last
await page.Locator("button").First.ClickAsync();

// click a visible button
await button.ClickAsync("button >> visible=true");
```

### 瀏覽器版本
- Chromium 94.0.4595.0
- Mozilla Firefox 91.0
- WebKit 15.0

## 版本 1.13

#### Playwright
- **🖖 Programmatic drag-and-drop support** via the [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) API.
- **🔎 Enhanced HAR**具有請求和回應的主體大小. 透過 `recordHar` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context). 使用

#### 工具
- Playwright 追蹤檢視器現在顯示參數、回傳值和 `console.log()` 呼叫。

#### 新增與重新編寫的指南
- [Intro](./intro.mdx)
- [Authentication](./auth.mdx)

#### 瀏覽器版本
- Chromium 93.0.4576.0
- Mozilla Firefox 90.0
- WebKit 14.2

#### 新的 Playwright API
- new `baseURL` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 和 [Browser.NewPageAsync()](/api/class-browser.mdx#browser-new-page)
- [Response.SecurityDetailsAsync()](/api/class-response.mdx#response-security-details) 和 [Response.ServerAddrAsync()](/api/class-response.mdx#response-server-addr)
- [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) 和 [Frame.DragAndDropAsync()](/api/class-frame.mdx#frame-drag-and-drop)
- [Download.CancelAsync()](/api/class-download.mdx#download-cancel)
- [Page.InputValueAsync()](/api/class-page.mdx#page-input-value), [Frame.InputValueAsync()](/api/class-frame.mdx#frame-input-value) 和 [ElementHandle.InputValueAsync()](/api/class-elementhandle.mdx#element-handle-input-value)
- new `force` 選項 in [Page.FillAsync()](/api/class-page.mdx#page-fill), [Frame.FillAsync()](/api/class-frame.mdx#frame-fill), 和 [ElementHandle.FillAsync()](/api/class-elementhandle.mdx#element-handle-fill)
- new `force` 選項 in [Page.SelectOptionAsync()](/api/class-page.mdx#page-select-選項), [Frame.SelectOptionAsync()](/api/class-frame.mdx#frame-select-選項), 和 [ElementHandle.SelectOptionAsync()](/api/class-elementhandle.mdx#element-handle-select-選項)

## 版本 1.12

#### 重點
- Playwright for .NET v1.12 現在穩定！
- Ships with the [codegen](./codegen.mdx) 和 [trace viewer](./trace-viewer.mdx) tools out-of-the-box

#### 瀏覽器版本
- Chromium 93.0.4530.0
- Mozilla Firefox 89.0
- WebKit 14.2

This version of Playwright was also tested against the following stable channels:
- Google Chrome 91
- Microsoft Edge 91


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
