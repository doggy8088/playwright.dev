---
id: release-notes
title: "發行說明"
toc_max_heading_level: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';
import ProgressiveImage from '@theme/ProgressiveImage';

## 版本 1.55

### 錄製測試
- 自動 `ToBeVisibleAsync()` 斷言：Codegen 現在可以為常見的 UI 互動產生自動 `ToBeVisibleAsync()` 斷言。此功能可以在 Codegen 設定 UI 中啟用。

### 重大變更
- ⚠️ 已移除對 Chromium 擴充功能 manifest v2 的支援。

### 其他
- 新增對 Debian 13 "Trixie" 的支援。
- 新增對 Xunit v3 的支援，作為 [`Microsoft.Playwright.Xunit.v3`](https://www.nuget.org/packages/Microsoft.Playwright.Xunit.v3) 的一部分
- 新增對 MSTest v4 的支援，作為 [`Microsoft.Playwright.MSTest.v4`](https://www.nuget.org/packages/Microsoft.Playwright.MSTest.v4) 的一部分

### 瀏覽器版本
- Chromium 140.0.7339.16
- Mozilla Firefox 141.0
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 139
- Microsoft Edge 139

## 版本 1.54

### 重點
- 在 [BrowserContext.CookiesAsync()](/api/class-browsercontext.mdx#browser-context-cookies) 和 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies) 中新增 cookie 屬性 `PartitionKey`。此屬性允許儲存和還原分割的 cookies。請參閱 [CHIPS MDN 文章](https://developer.mozilla.org/en-US/docs/Web/Privacy/Guides/Privacy_sandbox/Partitioned_cookies) 以取得更多資訊。請注意，瀏覽器對 cookie 分割有不同的支援和預設值。
- 在多個指令中新增選項 `--user-data-dir`。您可以指定相同的使用者資料目錄來重複使用瀏覽狀態，例如驗證，在不同的會話之間。
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 codegen --user-data-dir=./user-data
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 open` 不再開啟測試錄製器。請改用 `pwsh bin/Debug/netX/playwright.ps1 codegen`。

### 瀏覽器版本
- Chromium 139.0.7258.5
- Mozilla Firefox 140.0.2
- WebKit 26.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 140
- Microsoft Edge 140

## 版本 1.53

### 追蹤檢視器和 HTML 報告器更新
- 追蹤檢視器中的新步驟：![新的追蹤檢視器步驟](https://github.com/user-attachments/assets/1963ff7d-4070-41be-a79b-4333176921a2)
- 新方法 [Locator.Describe()](/api/class-locator.mdx#locator-describe) 用於描述定位器。用於追蹤檢視器。
  
  ```csharp
  var button = Page.GetByTestId("btn-sub").Describe("Subscribe button");
  await button.ClickAsync();
  ```
  
- `pwsh bin/Debug/netX/playwright.ps1 install --list` 現在會列出所有已安裝的瀏覽器、版本和位置。

### 瀏覽器版本
- Chromium 138.0.7204.4
- Mozilla Firefox 139.0
- WebKit 18.5

此版本也對以下穩定頻道進行了測試：
- Google Chrome 137
- Microsoft Edge 137

## 版本 1.52

### 重點
- 新方法 [Expect(Locator).ToContainClassAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-class) 用於人體工學地斷言元素上的個別類別名稱。
  
  ```csharp
    await Expect(Page.GetByRole(AriaRole.Listitem, new() { Name = "Ship v1.52" })).ToContainClassAsync("done");
  ```
  
- [Aria Snapshots](./aria-snapshots.mdx) 獲得兩個新屬性：[`/children`](./aria-snapshots.mdx#strict-matching) 用於嚴格匹配和 `/url` 用於連結。
  
  ```csharp
  await Expect(locator).ToMatchAriaSnapshotAsync(@"
    - list
      - /children: equal
      - listitem: Feature A
      - listitem:
        - link ""Feature B"":
          - /url: ""https://playwright.dev""
  ");
  ```
  
### 其他
- [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 中的新選項 [MaxRedirects](/api/class-apirequest.mdx#api-request-new-context-選項-max-redirects) 用於控制重定向的最大次數。

### 重大變更
- [Page.RouteAsync()](/api/class-page.mdx#page-route) 等方法中的 Glob URL 模式不再支援 `?` 和 `[]`。我們建議改用正規表示式。
- 方法 [Route.ContinueAsync()](/api/class-route.mdx#route-continue) 不再允許覆寫 `Cookie` 標頭。如果提供了 `Cookie` 標頭，它將被忽略，cookie 將從瀏覽器的 cookie 儲存區載入。若要設定自訂 cookie，請使用 [BrowserContext.AddCookiesAsync()](/api/class-browsercontext.mdx#browser-context-add-cookies)。
- macOS 13 現已棄用，將不再接收 WebKit 更新。請升級到更新的 macOS 版本以繼續受益於最新的 WebKit 改進。

### 瀏覽器版本
- Chromium 136.0.7103.25
- Mozilla Firefox 137.0
- WebKit 18.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 135
- Microsoft Edge 135

## 版本 1.51

### 重點
* 新選項 [IndexedDB](/api/class-browsercontext.mdx#browser-context-storage-state-選項-indexed-db) 用於 [BrowserContext.StorageStateAsync()](/api/class-browsercontext.mdx#browser-context-storage-state) 允許儲存和還原 IndexedDB 內容。當您的應用程式使用 [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 儲存身份驗證權杖（如 Firebase Authentication）時很有用。
  
  以下是遵循[身份驗證指南](./auth.mdx#reusing-signed-in-state)的範例：
  
  ```csharp
  // Save storage state into the file. Make sure to include IndexedDB.
  await context.StorageStateAsync(new()
  {
      Path = "../../../playwright/.auth/state.json",
      IndexedDB = true
  });
  
  // Create a new context with the saved storage state.
  var context = await browser.NewContextAsync(new()
  {
      StorageStatePath = "../../../playwright/.auth/state.json"
  });
  ```
  
* 新選項 [Visible](/api/class-locator.mdx#locator-filter-選項-visible) 用於 [Locator.Filter()](/api/class-locator.mdx#locator-filter) 允許只匹配可見元素。
  
  ```csharp
  // Ignore invisible todo items.
  var todoItems = Page.GetByTestId("todo-item").Filter(new() { Visible = true });
  // Check there are exactly 3 visible ones.
  await Expect(todoItems).ToHaveCountAsync(3);
  ```
  
* 新選項 `Contrast` 用於方法 [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media) 和 [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 允許模擬 `prefers-contrast` 媒體功能。
* 新選項 [FailOnStatusCode](/api/class-apirequest.mdx#api-request-new-context-選項-fail-on-status-code) 讓所有透過 [APIRequestContext] 發出的 fetch 請求在回應代碼不是 2xx 和 3xx 時拋出例外。

### 瀏覽器版本
* Chromium 134.0.6998.35
* Mozilla Firefox 135.0
* WebKit 18.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 133
* Microsoft Edge 133

## 版本 1.50

### 支援 Xunit
* 支援 xUnit 2.8+ via [Microsoft.Playwright.Xunit](https://www.nuget.org/packages/Microsoft.Playwright.Xunit). Follow our [Getting Started](./intro.mdx) guide to learn more.

### 其他
* Added 方法 [Expect(Locator).ToHaveAccessibleErrorMessageAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-error-message) to assert the Locator points to an element with a given [aria errormessage](https://w3c.github.io/aria/#aria-errormessage).

### UI 更新
* Codegen 中用於選取元素以產生 aria 快照的新按鈕。
* 其他詳細資訊（如按下的按鍵）現在會與追蹤中的動作 API 呼叫一起顯示。
* 在追蹤中顯示 `canvas` 內容容易出錯。顯示功能現在預設停用，可透過 `Display canvas content` UI 設定啟用。
* `Call` 和 `Network` 面板現在顯示其他時間資訊。

### 重大變更
* [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable) 和 [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) 現在在目標元素不是 `<input>`、`<select>` 或其他可編輯元素時會拋出例外。

### 瀏覽器版本
* Chromium 133.0.6943.16
* Mozilla Firefox 134.0
* WebKit 18.2

此版本也對以下穩定頻道進行了測試：
* Google Chrome 132
* Microsoft Edge 132

## 版本 1.49

### Aria 快照

新斷言 [Expect(Locator).ToMatchAriaSnapshotAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-match-aria-snapshot) 透過與預期的無障礙樹狀結構（以 YAML 表示）進行比較來驗證頁面結構。

```csharp
await page.GotoAsync("https://playwright.dev");
await Expect(page.Locator("body")).ToMatchAriaSnapshotAsync(@"
  - banner:
    - heading /Playwright enables reliable/ [level=1]
    - link ""Get started""
    - link ""Star microsoft/playwright on GitHub""
  - main:
    - img ""Browsers (Chromium, Firefox, WebKit)""
    - heading ""Any browser • Any platform • One API""
");
```

您可以使用 [測試產生器](./codegen) 或呼叫 [Locator.AriaSnapshotAsync()](/api/class-locator.mdx#locator-aria-snapshot).

在 [aria 快照指南](./aria-snapshots) 中了解更多。

### 追蹤群組

新方法 [Tracing.GroupAsync()](/api/class-tracing.mdx#tracing-group) 允許您在追蹤檢視器中視覺化地群組動作。

```csharp
// All actions between GroupAsync and GroupEndAsync
// will be shown in the trace viewer as a group.
await Page.Context.Tracing.GroupAsync("Open Playwright.dev > API");
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "API" }).ClickAsync();
await Page.Context.Tracing.GroupEndAsync();
```

### Breaking: `chrome` 和 `msedge` 頻道切換到新的無頭模式

如果您在 `playwright.config.ts` 中使用以下任一頻道，此變更會影響您：
- `chrome`, `chrome-dev`, `chrome-beta`, or `chrome-canary`
- `msedge`, `msedge-dev`, `msedge-beta`, or `msedge-canary`

更新到 Playwright v1.49 後，執行您的測試套件。如果仍然通過，您就可以繼續使用。如果不是，您可能需要更新您的快照，並調整一些關於 PDF 檢視器和擴充功能的測試程式碼。 請參閱...以取得更多詳細資訊.

### 嘗試新的 Chromium 無頭模式

您可以透過使用 `'chromium'` 頻道選擇新的無頭模式。如 [官方 Chrome 文件所述](https://developer.chrome.com/blog/chrome-headless-shell)：

> 另一方面，新的無頭模式是真正的 Chrome 瀏覽器，因此更真實、可靠，並提供更多功能。這使其更適合高精度的端到端網頁應用程式測試或瀏覽器擴充功能測試。

請參閱 [issue #33566](https://github.com/microsoft/playwright/issues/33566) 以查看您可能遇到的破壞性變更清單以及有關 Chromium headless 的更多詳細資訊。如果您在選擇加入後看到任何問題，請提交 issue。

```xml title="runsettings.xml"
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <LaunchOptions>
      <Channel>chromium</Channel>
    </LaunchOptions>
  </Playwright>
</RunSettings>
```

```bash
dotnet test -- Playwright.BrowserName=chromium Playwright.LaunchOptions.Channel=chromium
```

### 其他
- Ubuntu 20.04 和 Debian 11 上的 WebKit 將不再有更新。我們建議將您的作業系統更新到較新版本。
- `<canvas>` 元素在快照內現在會繪製預覽。

### 瀏覽器版本
- Chromium 131.0.6778.33
- Mozilla Firefox 132.0
- WebKit 18.2

此版本也對以下穩定頻道進行了測試：
- Google Chrome 130
- Microsoft Edge 130

## 版本 1.48

### WebSocket 路由

新方法s [Page.RouteWebSocketAsync()](/api/class-page.mdx#page-route-web-socket) 和 [BrowserContext.RouteWebSocketAsync()](/api/class-browsercontext.mdx#browser-context-route-web-socket) 允許 intercept, modify and mock WebSocket connections initiated in the page. Below is a simple example that mocks WebSocket communication by responding to a `"request"` with a `"response"`.

```csharp
await page.RouteWebSocketAsync("/ws", ws => {
  ws.OnMessage(frame => {
    if (frame.Text == "request")
      ws.Send("response");
  });
});
```

請參閱 [WebSocketRoute] 以取得更多詳細資訊。

### UI 更新
- HTML 報告中註釋和測試位置的新「複製」按鈕。
- 路由方法呼叫（如 [Route.FulfillAsync()](/api/class-route.mdx#route-fulfill)）不再顯示在報告和追蹤檢視器中。您可以在網路標籤中查看哪些網路請求被路由。
- 網路標籤中請求的新「複製為 cURL」和「複製為 fetch」按鈕。

### 其他
- 新方法 [Page.RequestGCAsync()](/api/class-page.mdx#page-request-gc) may help detect memory leaks.
- [APIRequestContext] 發出的請求現在在 HAR 中記錄詳細的時間和安全資訊。

### 瀏覽器版本
- Chromium 130.0.6723.19
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 129
- Microsoft Edge 129

## 版本 1.47

### 網路分頁改進

追蹤檢視器中的網路頁籤有幾項不錯的改進：
- filtering by asset type and URL
- better display of query string parameters
- preview of font assets

![網路頁籤現在有篩選器](https://github.com/user-attachments/assets/4bd1b67d-90bd-438b-a227-00b9e86872e2)

### 其他
- `mcr.microsoft.com/playwright/dotnet:v1.47.0` 現在提供基於 Ubuntu 24.04 Noble 的 Playwright 映像。要使用基於 22.04 jammy 的映像，請改用 `mcr.microsoft.com/playwright/dotnet:v1.47.0-jammy`。
- Playwright Docker 映像的 `:latest`/`:focal`/`:jammy` 標籤不再發布。請固定到特定版本以獲得更好的穩定性和可重現性。
- TLS 用戶端憑證現在可以透過傳遞 [ClientCertificates.Cert](/api/class-browser.mdx#browser-new-context-選項-client-certificates) 和 [ClientCertificates.Key](/api/class-browser.mdx#browser-new-context-選項-client-certificates) 作為位元組陣列而非檔案路徑從記憶體傳遞。
- [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) 中的 [NoWaitAfter](/api/class-locator.mdx#locator-select-選項-選項-no-wait-after) 已被棄用。
- 我們已看到 WebKit 中的 WebGL 在 GitHub Actions `macos-13` 上運作異常的回報。我們建議將 GitHub Actions 升級到 `macos-14`。

### 瀏覽器版本
- Chromium 129.0.6668.29
- Mozilla Firefox 130.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 128
- Microsoft Edge 128

## 版本 1.46

### TLS Client Certificates

Playwright 現在允許提供用戶端憑證，以便伺服器可以根據 TLS 用戶端驗證的規定來驗證它們。

您可以將用戶端憑證作為 [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 和 [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 的參數提供。以下程式碼片段設定 `https://example.com` 的用戶端憑證：

```csharp
var context = await Browser.NewContextAsync(new() {
  ClientCertificates = [
    new() {
      Origin = "https://example.com",
      CertPath = "client-certificates/cert.pem",
      KeyPath = "client-certificates/key.pem",
    }
  ]
});
```

### 追蹤檢視器更新
- 文字附件的內容現在會在附件窗格中內嵌呈現。
- 新設定以顯示/隱藏路由動作，如 [Route.ContinueAsync()](/api/class-route.mdx#route-continue)。
- Request 方法 and status are shown in the network details tab.
- 複製源檔案位置到剪貼簿的新按鈕。
- Metadata pane現在displays the `BaseURL`.

### 其他
- [ApiRequestContext.FetchAsync()](/api/class-apirequestcontext.mdx#api-request-context-fetch) 中的新 `maxRetries` 選項，在 `ECONNRESET` 網路錯誤時重試。

### 瀏覽器版本
- Chromium 128.0.6613.18
- Mozilla Firefox 128.0
- WebKit 18.0

此版本也對以下穩定頻道進行了測試：
- Google Chrome 127
- Microsoft Edge 127

## 版本 1.45

### 時鐘

利用新的 [Clock] API 允許在測試中操控和控制時間以驗證與時間相關的行為。此 API 涵蓋許多常見場景，包括：
* testing with predefined time;
* keeping consistent time and timers;
* monitoring inactivity;
* ticking through time manually.

```csharp
// Initialize clock with some time before the test time and let the page load naturally.
// `Date.now` will progress as the timers fire.
await Page.Clock.InstallAsync(new()
{
  TimeDate = new DateTime(2024, 2, 2, 8, 0, 0)
});
await Page.GotoAsync("http://localhost:3333");

// Pretend that the user closed the laptop lid and opened it again at 10am.
// Pause the time once reached that point.
await Page.Clock.PauseAtAsync(new DateTime(2024, 2, 2, 10, 0, 0));

// Assert the page state.
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:00:00 AM");

// Close the laptop lid again and open it at 10:30am.
await Page.Clock.FastForwardAsync("30:00");
await Expect(Page.GetByTestId("current-time")).ToHaveTextAsync("2/2/2024, 10:30:00 AM");
```

請參閱 [時鐘指南](./clock.mdx) 以取得更多詳細資訊。

### 其他
- 方法 [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) 現在支援 uploading a directory for `<input type=file webkitdirectory>` elements.
  
  ```csharp
  await page.GetByLabel("Upload directory").SetInputFilesAsync("mydir");
  ```
  
- 多個方法（如 [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) or [Locator.PressAsync()](/api/class-locator.mdx#locator-press) 現在支援 a `ControlOrMeta` modifier key. 此鍵 對應到 `Meta` on macOS and 對應到 `Control` on Windows and Linux.
  
  ```csharp
  // Press the common keyboard shortcut Control+S or Meta+S to trigger a "Save" operation.
  await page.Keyboard.PressAsync("ControlOrMeta+S");
  ```
  
- 新屬性 `httpCredentials.send` 在 [ApiRequest.NewContextAsync()](/api/class-apirequest.mdx#api-request-new-context) 中，允許永遠傳送 `Authorization` 標頭或僅在回應 `401 Unauthorized` 時傳送。
- Playwright 現在支援 Chromium, Firefox and WebKit on Ubuntu 24.04.
- v1.45是最後一個接收receive WebKit update for macOS 12 Monterey. 請更新macOS以繼續使用the latest WebKit.

### 瀏覽器版本
* Chromium 127.0.6533.5
* Mozilla Firefox 127.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 126
* Microsoft Edge 126

## 版本 1.44

### 新的 API

**無障礙斷言**
- [Expect(Locator).ToHaveAccessibleNameAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name) 檢查元素是否具有指定的無障礙名稱：
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleNameAsync("Submit");
  ```
  
- [Expect(Locator).ToHaveAccessibleDescriptionAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description) 檢查元素是否具有指定的無障礙描述：
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  await Expect(locator).ToHaveAccessibleDescriptionAsync("Upload a photo");
  ```
  
- [Expect(Locator).ToHaveRoleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-role) 檢查元素是否具有指定的 ARIA 角色：
  
  ```csharp
  var locator = Page.GetByTestId("save-button");
  await Expect(locator).ToHaveRoleAsync(AriaRole.Button);
  ```
  
**定位器處理器**
- 執行透過 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 新增的處理器後，Playwright 現在會等待直到觸發處理器的覆蓋層不再可見。您可以使用新的 `NoWaitAfter` 選項來選擇退出此行為。
- 您可以在 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 中使用新的 `Times` 選項來指定處理器應執行的最大次數。
- [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 中的處理器現在接受定位器作為參數。
- 新的 [Page.RemoveLocatorHandlerAsync()](/api/class-page.mdx#page-remove-locator-handler) 方法用於移除先前新增的定位器處理器。

```csharp
var locator = Page.GetByText("This interstitial covers the button");
await Page.AddLocatorHandlerAsync(locator, async (overlay) =>
{
    await overlay.Locator("#close").ClickAsync();
}, new() { Times = 3, NoWaitAfter = true });
// 執行可能被覆蓋層中斷的測試。
// ...
await Page.RemoveLocatorHandlerAsync(locator);
```

**其他選項**
- 新方法 [FormData.Append()](/api/class-formdata.mdx#form-data-append) 允許在 `APIRequestContext.FetchAsync()` 的 [`Multipart`](./api/class-apirequestcontext#api-request-context-fetch-選項-multipart) 選項中指定相同名稱的重複欄位：
  
  ```csharp
  var formData = Context.APIRequest.CreateFormData();
  formData.Append("file", new FilePayload()
  {
      Name = "f1.js",
      MimeType = "text/javascript",
      Buffer = System.Text.Encoding.UTF8.GetBytes("var x = 2024;")
  });
  formData.Append("file", new FilePayload()
  {
      Name = "f2.txt",
      MimeType = "text/plain",
      Buffer = System.Text.Encoding.UTF8.GetBytes("hello")
  });
  var response = await Context.APIRequest.PostAsync("https://example.com/uploadFiles", new() { Multipart = formData });
  ```
  
- [Expect(Page).ToHaveURLAsync()](/api/class-pageassertions.mdx#page-assertions-to-have-url) 現在支援 `IgnoreCase` [選項](./api/class-pageassertions#page-assertions-to-have-url-選項-ignore-case).

### 瀏覽器版本
* Chromium 125.0.6422.14
* Mozilla Firefox 125.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 124
* Microsoft Edge 124

## 版本 1.43

### 新的 API
- 方法 [BrowserContext.ClearCookiesAsync()](/api/class-browsercontext.mdx#browser-context-clear-cookies) 現在支援 filters to remove only some cookies.
  
  ```csharp
  // Clear all cookies.
  await Context.ClearCookiesAsync();
  // New: clear cookies with a particular name.
  await Context.ClearCookiesAsync(new() { Name = "session-id" });
  // New: clear cookies for a particular domain.
  await Context.ClearCookiesAsync(new() { Domain = "my-origin.com" });
  ```
  
- 新屬性 [Locator.ContentFrame](/api/class-locator.mdx#locator-content-frame) 將 [Locator] 物件轉換為 [FrameLocator]。當您在某處獲得 [Locator] 物件，然後想要與框架內的內容互動時，這會很有用。
  
  ```csharp
  var locator = Page.Locator("iframe[name='embedded']");
  // ...
  var frameLocator = locator.ContentFrame;
  await frameLocator.GetByRole(AriaRole.Button).ClickAsync();
  ```
  
- 新屬性 [FrameLocator.Owner](/api/class-framelocator.mdx#frame-locator-owner) 將 [FrameLocator] 物件轉換為 [Locator]。當您在某處獲得 [FrameLocator] 物件，然後想要與 `iframe` 元素互動時，這會很有用。
  
  ```csharp
  var frameLocator = page.FrameLocator("iframe[name='embedded']");
  // ...
  var locator = frameLocator.Owner;
  await Expect(locator).ToBeVisibleAsync();
  ```
  
### 瀏覽器版本
* Chromium 124.0.6367.8
* Mozilla Firefox 124.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 123
* Microsoft Edge 123

## 版本 1.42

### 新的定位器處理器

新方法 [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) 註冊一個回呼函數，當指定元素變為可見且可能阻擋 Playwright 動作時會被調用。回呼函數可以移除覆蓋層。以下是一個當 cookie 對話框出現時關閉它的範例。

```csharp
// Setup the handler.
await Page.AddLocatorHandlerAsync(
    Page.GetByRole(AriaRole.Heading, new() { Name = "Hej! You are in control of your cookies." }),
    async () =>
    {
        await Page.GetByRole(AriaRole.Button, new() { Name = "Accept all" }).ClickAsync();
    });
// Write the test as usual.
await Page.GotoAsync("https://www.ikea.com/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Collection of blue and white" }).ClickAsync();
await Expect(Page.GetByRole(AriaRole.Heading, new() { Name = "Light and easy" })).ToBeVisibleAsync();
```

### 新的 API
- [Page.PdfAsync()](/api/class-page.mdx#page-pdf) 接受兩個新選項 [Tagged](/api/class-page.mdx#page-pdf-選項-tagged) 和 [Outline](/api/class-page.mdx#page-pdf-選項-outline)。

### 公告
* ⚠️ 不再支援 Ubuntu 18。

### 瀏覽器版本
* Chromium 123.0.6312.4
* Mozilla Firefox 123.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 122
* Microsoft Edge 123

## 版本 1.41

### 新的 API
- 新方法 [Page.UnrouteAllAsync()](/api/class-page.mdx#page-unroute-all) 移除由 [Page.RouteAsync()](/api/class-page.mdx#page-route) 和 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 註冊的所有路由。可選擇等待進行中的路由完成，或忽略來自它們的任何錯誤。
- 新方法 [BrowserContext.UnrouteAllAsync()](/api/class-browsercontext.mdx#browser-context-unroute-all) 移除由 [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 註冊的所有路由。可選擇等待進行中的路由完成，或忽略來自它們的任何錯誤。
- 新選項s [Style](/api/class-page.mdx#page-screenshot-選項-style) in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 和 [Style](/api/class-locator.mdx#locator-screenshot-選項-style) in [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot)以新增custom CSS to the page在執行...之前a screenshot.

### 瀏覽器版本
* Chromium 121.0.6167.57
* Mozilla Firefox 121.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 120
* Microsoft Edge 120

## 版本 1.40

### 測試產生器更新

![Playwright Test Generator](https://github.com/microsoft/playwright/assets/9881434/e8d67e2e-f36d-4301-8631-023948d3e190)

新的產生斷言工具：
- "Assert visibility" 工具產生 [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible)。
- "Assert value" 工具產生 [Expect(Locator).ToHaveValueAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-value)。
- "Assert text" 工具產生 [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text)。

以下是產生的測試與斷言範例：

```csharp
await Page.GotoAsync("https://playwright.dev/");
await Page.GetByRole(AriaRole.Link, new() { Name = "Get started" }).ClickAsync();
await Expect(Page.GetByLabel("Breadcrumbs").GetByRole(AriaRole.List)).ToContainTextAsync("Installation");
await Expect(Page.GetByLabel("Search")).ToBeVisibleAsync();
await Page.GetByLabel("Search").ClickAsync();
await Page.GetByPlaceholder("Search docs").FillAsync("locator");
await Expect(Page.GetByPlaceholder("Search docs")).ToHaveValueAsync("locator");
```

### 新的 API
- Options [Reason](/api/class-page.mdx#page-close-選項-reason) in [Page.CloseAsync()](/api/class-page.mdx#page-close), [Reason](/api/class-browsercontext.mdx#browser-context-close-選項-reason) in [BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close) 和 [Reason](/api/class-browser.mdx#browser-close-選項-reason) in [Browser.CloseAsync()](/api/class-browser.mdx#browser-close). Close reason is reported for all operations interrupted by the closure.
- 選項 [FirefoxUserPrefs](/api/class-browsertype.mdx#browser-type-launch-persistent-context-選項-firefox-user-prefs) in [BrowserType.LaunchPersistentContextAsync()](/api/class-browsertype.mdx#browser-type-launch-persistent-context).

### 其他變更
- Methods [Download.PathAsync()](/api/class-download.mdx#download-path) 和 [Download.CreateReadStreamAsync()](/api/class-download.mdx#download-create-read-stream) throw an error for failed and cancelled downloads.
- Playwright [docker image](./docker.mdx)現在comes with .NET 8 (new LTS).

### 瀏覽器版本
* Chromium 120.0.6099.28
* Mozilla Firefox 119.0
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 119
* Microsoft Edge 119

## 版本 1.39

長青瀏覽器更新。

### 瀏覽器版本
* Chromium 119.0.6045.9
* Mozilla Firefox 118.0.1
* WebKit 17.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 118
* Microsoft Edge 118

## 版本 1.38

### 追蹤檢視器更新

![Playwright Trace Viewer](https://github.com/microsoft/playwright/assets/746130/0c41e20d-c54b-4600-8ca8-1cbb6393ddef)
1. Zoom into time range.
1. Network panel redesign.

### 新的 API
- [BrowserContext.WebError](/api/class-browsercontext.mdx#browser-context-event-web-error)
- [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially)

### 棄用
* 以下方法已棄用：[Page.TypeAsync()](/api/class-page.mdx#page-type)、[Frame.TypeAsync()](/api/class-frame.mdx#frame-type)、[Locator.TypeAsync()](/api/class-locator.mdx#locator-type) 和 [ElementHandle.TypeAsync()](/api/class-elementhandle.mdx#element-handle-type)。請改用速度更快的 [Locator.FillAsync()](/api/class-locator.mdx#locator-fill)。只有在頁面有特殊的鍵盤處理需求，需要逐一按鍵時，才使用 [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially)。

### 瀏覽器版本
* Chromium 117.0.5938.62
* Mozilla Firefox 117.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 116
* Microsoft Edge 116

## 版本 1.37

### 📚 Debian 12 Bookworm Support

Playwright 現在支援 Debian 12 Bookworm on both x86_64 and arm64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux 支援如下：

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11 | Debian 12 |
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ | ✅ |

### 瀏覽器版本
* Chromium 116.0.5845.82
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 115
* Microsoft Edge 115

## 版本 1.36

🏝️ Summer maintenance release.

### 瀏覽器版本
* Chromium 115.0.5790.75
* Mozilla Firefox 115.0
* WebKit 17.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.35

### 重點
* 新選項 `MaskColor`用於方法[Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 和 [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) 以變更預設遮罩顏色。
* 新的 `uninstall` CLI 命令用於解除安裝瀏覽器二進位檔：
  
  ```bash
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall # remove browsers installed by this installation
  $ pwsh bin/Debug/netX/playwright.ps1 uninstall --all # remove all ever-install Playwright browsers
  ```
  
### 瀏覽器版本
* Chromium 115.0.5790.13
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 114
* Microsoft Edge 114

## 版本 1.34

### 重點
* 新的 [Locator.And()](/api/class-locator.mdx#locator-and) 用於建立符合兩個定位器的定位器。
  
  ```csharp
  var button = page.GetByRole(AriaRole.BUTTON).And(page.GetByTitle("Subscribe"));
  ```
  
* 新事件 [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) 和 [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog) 用於訂閱來自給定瀏覽器上下文中任何頁面的對話框和主控台訊息。使用新方法 [ConsoleMessage.Page](/api/class-consolemessage.mdx#console-message-page) 和 [Dialog.Page](/api/class-dialog.mdx#dialog-page) 精確定位事件來源。

### 瀏覽器版本
* Chromium 114.0.5735.26
* Mozilla Firefox 113.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 113
* Microsoft Edge 113

## 版本 1.33

### 定位器更新
* 使用 [Locator.Or()](/api/class-locator.mdx#locator-or) 建立符合兩個定位器其中之一的定位器。考慮這樣的場景：您想要點選「New email」按鈕，但有時會出現安全設定對話框。在這種情況下，您可以等待「New email」按鈕或對話框，並相應地採取行動：
  
  ```csharp
  var newEmail = Page.GetByRole(AriaRole.Button, new() { Name = "New email" });
  var dialog = Page.GetByText("Confirm security settings");
  await Expect(newEmail.Or(dialog)).ToBeVisibleAsync();
  if (await dialog.IsVisibleAsync())
    await Page.GetByRole(AriaRole.Button, new() { Name = "Dismiss" }).ClickAsync();
  await newEmail.ClickAsync();
  ```
  
* 在 [Locator.Filter()](/api/class-locator.mdx#locator-filter) 中使用新選項 [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) 和 [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) 來尋找**不符合**特定條件的元素。
  
  ```csharp
  var rowLocator = Page.Locator("tr");
  await rowLocator
      .Filter(new() { HasNotText = "text in column 1" })
      .Filter(new() { HasNot = Page.GetByRole(AriaRole.Button, new() { Name = "column 2 button" })})
      .ScreenshotAsync();
  ```
  
* 使用新的網頁優先斷言 [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached) 確保元素存在於頁面的 DOM 中。不要與 [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible) 混淆，後者確保元素既附加又可見。

### 新的 API
- [Locator.Or()](/api/class-locator.mdx#locator-or)
- 新選項 [HasNot](/api/class-locator.mdx#locator-filter-選項-has-not) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- 新選項 [HasNotText|HasNotTextRegex](/api/class-locator.mdx#locator-filter-選項-has-not-text) in [Locator.Filter()](/api/class-locator.mdx#locator-filter)
- [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached)
- 新選項 [Timeout](/api/class-route.mdx#route-fetch-選項-timeout) in [Route.FetchAsync()](/api/class-route.mdx#route-fetch)

### ⚠️ Breaking change
* `mcr.microsoft.com/playwright/dotnet:v1.33.0` 現在提供基於 Ubuntu Jammy 的 Playwright 映像。若要使用基於 focal 的映像，請改用 `mcr.microsoft.com/playwright/dotnet:v1.33.0-focal`。

### 瀏覽器版本
* Chromium 113.0.5672.53
* Mozilla Firefox 112.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 112
* Microsoft Edge 112

## 版本 1.32

### 新的 API
- 新選項s [UpdateMode](/api/class-page.mdx#page-route-from-har-選項-update-mode) 和 [UpdateContent](/api/class-page.mdx#page-route-from-har-選項-update-content) in [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har).
- Chaining existing locator objects, see [locator docs](./locators.mdx#matching-inside-a-locator) for details.
- 新選項 [Name](/api/class-tracing.mdx#tracing-start-chunk-選項-name) in 方法 [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk).

### 瀏覽器版本
* Chromium 112.0.5615.29
* Mozilla Firefox 111.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 111
* Microsoft Edge 111

## 版本 1.31

### 新的 API
- 新的斷言 [Expect(Locator).ToBeInViewportAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-in-viewport) 確保定位器指向與視埠相交的元素，根據[交集觀察器 API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)。
  
  ```csharp
  var locator = Page.GetByRole(AriaRole.Button);
  
  // Make sure at least some part of element intersects viewport.
  await Expect(locator).ToBeInViewportAsync();
  
  // Make sure element is fully outside of viewport.
  await Expect(locator).Not.ToBeInViewportAsync();
  
  // Make sure that at least half of the element intersects viewport.
  await Expect(locator).ToBeInViewportAsync(new() { Ratio = 0.5 });
  ```
  
- 新方法s [BrowserContext.NewCDPSessionAsync()](/api/class-browsercontext.mdx#browser-context-new-cdp-session) 和 [Browser.NewBrowserCDPSessionAsync()](/api/class-browser.mdx#browser-new-browser-cdp-session) create a [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) session for the page and browser respectively.

### 其他
- 追蹤檢視器中的 DOM 快照現在可以在單獨的視窗中開啟。
- 新選項 [MaxRedirects](/api/class-route.mdx#route-fetch-選項-max-redirects) 用於方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch).
- Playwright 現在支援 Debian 11 arm64.
- Official [docker images](./docker.mdx)現在include Node 18 instead of Node 16.

### 瀏覽器版本
* Chromium 111.0.5563.19
* Mozilla Firefox 109.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 110
* Microsoft Edge 110

## 版本 1.30

### 瀏覽器版本
* Chromium 110.0.5481.38
* Mozilla Firefox 108.0.2
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 109
* Microsoft Edge 109

## 版本 1.29

### 新的 API
- 新方法 [Route.FetchAsync()](/api/class-route.mdx#route-fetch) 和新選項 `Json` 用於[Route.FulfillAsync()](/api/class-route.mdx#route-fulfill):
  
  ```csharp
  await Page.RouteAsync("**/api/settings", async route => {
    // Fetch original settings.
    var response = await route.FetchAsync();
  
    // Force settings theme to a predefined value.
    var json = await response.JsonAsync<MyDataType>();
    json.Theme = "Solarized";
  
    // Fulfill with modified data.
    await route.FulfillAsync(new() {
      Json = json
    });
  });
  ```
  
- 新方法 [Locator.AllAsync()](/api/class-locator.mdx#locator-all) to iterate over all matching elements:
  
  ```csharp
  // Check all checkboxes!
  var checkboxes = Page.GetByRole(AriaRole.Checkbox);
  foreach (var checkbox in await checkboxes.AllAsync())
    await checkbox.CheckAsync();
  ```
  
- [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-選項) matches現在by value or label:
  
  ```html
  <select multiple>
    <選項 value="red">Red</選項>
    <選項 value="green">Green</選項>
    <選項 value="blue">Blue</選項>
  </select>
  ```
  
  ```csharp
  await element.SelectOptionAsync("Red");
  ```
  
### 瀏覽器版本
* Chromium 109.0.5414.46
* Mozilla Firefox 107.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 108
* Microsoft Edge 108

## 版本 1.28

### Playwright 工具
* **CodeGen 中的即時定位器。** 使用「探索」工具為頁面上的任何元素產生定位器。

![Locator Explorer](https://user-images.githubusercontent.com/9798949/202293757-2e3ec0ac-1feb-4d6f-9935-73e08658b76d.png)

### 新的 API
- [Locator.BlurAsync()](/api/class-locator.mdx#locator-blur)
- [Locator.ClearAsync()](/api/class-locator.mdx#locator-clear)

### 瀏覽器版本
* Chromium 108.0.5359.29
* Mozilla Firefox 106.0
* WebKit 16.4

此版本也對以下穩定頻道進行了測試：
* Google Chrome 107
* Microsoft Edge 107

## 版本 1.27

### 定位器

使用這些新 API 編寫定位器是一種樂趣：
- [Page.GetByText()](/api/class-page.mdx#page-get-by-text) 透過文字內容定位。
- [Page.GetByRole()](/api/class-page.mdx#page-get-by-role) 透過 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 定位。
- [Page.GetByLabel()](/api/class-page.mdx#page-get-by-label)以定位a form control by associated label's text.
- [Page.GetByTestId()](/api/class-page.mdx#page-get-by-test-id)以定位an element based on its `data-testid` attribute (other attribute can be configured).
- [Page.GetByPlaceholder()](/api/class-page.mdx#page-get-by-placeholder)以定位an input by placeholder.
- [Page.GetByAltText()](/api/class-page.mdx#page-get-by-alt-text)以定位an element, usually image, by its text alternative.
- [Page.GetByTitle()](/api/class-page.mdx#page-get-by-title)以定位an element by its title.

```csharp
await page.GetByLabel("User Name").FillAsync("John");

await page.GetByLabel("Password").FillAsync("secret-password");

await page.GetByRole(AriaRole.Button, new() { NameString = "Sign in" }).ClickAsync();

await Expect(Page.GetByText("Welcome, John!")).ToBeVisibleAsync();
```

所有相同的方法在 [Locator]、[FrameLocator] 和 [Frame] 類別中也都可以使用。

### 其他重點
- 如 v1.25 中所宣布，Ubuntu 18 將在 2022 年 12 月起不再受支援。除此之外，從下一個 Playwright 版本開始，Ubuntu 18 上將不會有 WebKit 更新。

### 行為變更
- [Expect(Locator).ToHaveAttributeAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute) 使用空值不再比對缺少的屬性。例如，當 `button` **沒有** `disabled` 屬性時，以下程式碼片段將會成功。
  
  ```csharp
  await Expect(Page.GetByRole(AriaRole.Button)).ToHaveAttributeAsync("disabled", "");
  ```
  
### 瀏覽器版本
* Chromium 107.0.5304.18
* Mozilla Firefox 105.0.1
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 106
* Microsoft Edge 106

## 版本 1.26

### 斷言
- 新選項 `Enabled` for [Expect(Locator).ToBeEnabledAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-enabled).
- [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text)現在pierces open shadow roots.
- 新選項 `Editable` for [Expect(Locator).ToBeEditableAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-editable).
- 新選項 `Visible` for [Expect(Locator).ToBeVisibleAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-visible).
- [Expect(Response).ToBeOKAsync()](/api/class-apiresponseassertions.mdx#api-response-assertions-to-be-ok) 現在可用.

### 其他重點
- 新選項 `MaxRedirects` for [ApiRequestContext.GetAsync()](/api/class-apirequestcontext.mdx#api-request-context-get)和其他方法以limit redirect count.
- Codegen 現在支援 MSTest and NUnit frameworks.
- 現在支援 ASP .NET。

### 行為變更

A bunch of Playwright APIs already support the `WaitUntil: WaitUntilState.DOMContentLoaded` 選項. For example:

```csharp
await Page.GotoAsync("https://playwright.dev", new() { WaitUntil = WaitUntilState.DOMContentLoaded });
```

在 1.26 之前，這將等待所有 iframe 觸發 `DOMContentLoaded` 事件。

為了與網頁規範保持一致，`WaitUntilState.DOMContentLoaded` 值只會等待目標框架觸發 `'DOMContentLoaded'` 事件。使用 `WaitUntil: WaitUntilState.Load` 來等待所有 iframe。

### 瀏覽器版本
* Chromium 106.0.5249.30
* Mozilla Firefox 104.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 105
* Microsoft Edge 105

## 版本 1.25

### New .runsettings file的支援

`Microsoft.Playwright.NUnit` 和 `Microsoft.Playwright.MSTest` 現在會在執行端對端測試時考慮 `.runsettings` 檔案和透過 CLI 傳遞的設定。請參閱[文件](./test-runners)以取得支援設定的完整清單。

以下現在可以正常運作：

```xml
<?xml version="1.0" encoding="utf-8"?>
<RunSettings>
  <!-- Playwright -->
  <Playwright>
    <BrowserName>chromium</BrowserName>
    <ExpectTimeout>5000</ExpectTimeout>
    <LaunchOptions>
      <Headless>true</Headless>
      <Channel>msedge</Channel>
    </LaunchOptions>
  </Playwright>
  <!-- General run configuration -->
  <RunConfiguration>
    <EnvironmentVariables>
      <!-- For debugging selectors, it's recommend以設定the following environment variable -->
      <DEBUG>pw:api</DEBUG>
    </EnvironmentVariables>
  </RunConfiguration>
</RunSettings>
```

### 公告
* 🪦 這是最後一個支援 macOS 10.15 的版本（自 1.21 起已棄用）。
* ⚠️ Ubuntu 18 現已棄用，將從 2022 年 12 月起不再受支援。

### 瀏覽器版本
* Chromium 105.0.5195.19
* Mozilla Firefox 103.0
* WebKit 16.0

此版本也對以下穩定頻道進行了測試：
* Google Chrome 104
* Microsoft Edge 104

## 版本 1.24

<div className="embed-youtube">

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9F05o1shxcY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</div>

### 🐂 Debian 11 Bullseye Support

Playwright 現在支援 Debian 11 Bullseye on x86_64 for Chromium, Firefox and WebKit. 如果您遇到任何問題，請告訴我們！

Linux 支援如下：

|          | Ubuntu 20.04 | Ubuntu 22.04 | Debian 11
| :--- | :---: | :---: | :---: | :---: |
| Chromium | ✅ | ✅ | ✅ |
| WebKit | ✅ | ✅ | ✅ |
| Firefox | ✅ | ✅ | ✅ |

### 新的介紹文件

我們重寫了入門文件，使其更專注於端對端測試。請在 [playwright.dev](./intro).

## 版本 1.23

### API 測試

Playwright for .NET 1.23 引入新的 [API 測試](./api/class-apirequestcontext)，讓您可以直接從 .NET 向伺服器發送請求！現在您可以：
- test your server API
- prepare server side state before visiting the web application in a test
- validate server side post-conditions after running some actions in the browser

要代表 Playwright 的 Page 執行請求，請使用**新的 [Page.APIRequest](/api/class-page.mdx#page-request) API**：

```csharp
// Do a GET request on behalf of page
var response = await Page.APIRequest.GetAsync("http://example.com/foo.json");
Console.WriteLine(response.Status);
Console.WriteLine(response.StatusText);
Console.WriteLine(response.Ok);
Console.WriteLine(response.Headers["Content-Type"]);
Console.WriteLine(await response.TextAsync());
Console.WriteLine((await response.JsonAsync())?.GetProperty("foo").GetString());
```

在我們的 [API 測試指南](./api-testing).

### 網路重播

現在您可以將網路流量錄製到 HAR 檔案中，並在測試中重複使用此流量。

To record network into HAR file:

```bash
pwsh bin/Debug/netX/playwright.ps1 open --save-har=example.har --save-har-glob="**/api/**" https://example.com
```

或者，您可以透過程式方式錄製 HAR：

```csharp
var context = await browser.NewContextAsync(new()
{
  RecordHarPath = harPath,
  RecordHarUrlFilterString = "**/api/**",
});

// ... Perform actions ...

// 關閉上下文以確保 HAR 儲存到磁碟。
context.CloseAsync();
```

使用新方法 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 或 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 從 [HAR](http://www.softwareishard.com/blog/har-12-spec/) 檔案提供符合的回應：

```csharp
await context.RouteFromHARAsync("example.har");
```

在 [我們的文件](./mock.mdx#mocking-with-har-files).

### 進階路由

您現在可以使用 [Route.FallbackAsync()](/api/class-route.mdx#route-fallback) to defer routing to other handlers.

Consider the following example:

```csharp
// Remove a header from all requests.
await page.RouteAsync("**/*", async route =>
{
    var headers = route.Request.Headers;
    headers.Remove("X-Secret");
    await route.ContinueAsync(new() { Headers = headers });
});

// Abort all images.
await page.RouteAsync("**/*", async route =>
{
    if (route.Request.ResourceType == "image")
    {
        await route.AbortAsync();
    }
    else
    {
        await route.FallbackAsync();
    }
});
```

請注意，新方法 [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har) 和 [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har) 也會參與路由處理，並且可以被延遲。

### Web-First 斷言更新
* 新方法 [Expect(Locator).ToHaveValuesAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-values) 用於斷言 `<select multiple>` 元素的所有選取值。
* 方法 [Expect(Locator).ToContainTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text) 和 [Expect(Locator).ToHaveTextAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) 現在接受 `ignoreCase` 選項。

### 其他
* 如果有阻礙您的 Service Worker，您現在可以透過新的上下文選項 `serviceWorkers` 輕鬆停用它：
  
  ```csharp
  var context = await Browser.NewContextAsync(new()
  {
      ServiceWorkers = ServiceWorkerPolicy.Block
  });
  ```
  
* Using `.zip` path for `recordHar` context 選項 automatically zips the resulting HAR:
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har.zip" });
  ```
  
* 如果您打算手動編輯 HAR，請考慮使用僅記錄重播所需基本資訊的 `"minimal"` HAR 記錄模式：
  
  ```csharp
  var context = await Browser.NewContextAsync(new() { RecordHarPath = "example.har", RecordHarMode = HarMode.Minimal });
  ```
  
* Playwright 現在在 Ubuntu 22 amd64 和 Ubuntu 22 arm64 上執行。
* Playwright for .NET 現在支援 **linux-arm64** and provides a **arm64 Ubuntu 20.04 Docker image** for it.

## 版本 1.22

### 重點
- 角色選擇器，允許依據 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 選擇元素。
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  在 [我們的文件](./locators.mdx#locate-by-role).
- 新的 [Locator.Filter()](/api/class-locator.mdx#locator-filter) API to filter an existing locator
  
  ```csharp
  var buttons = page.Locator("role=button");
  // ...
  var submitLocator = buttons.Filter(new() { HasText = "Sign up" });
  await submitLocator.ClickAsync();
  ```
  
## 版本 1.21

### 重點
- 新的角色選擇器，允許依據 [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 和 [accessible name](https://w3c.github.io/accname/#dfn-accessible-name) 選擇元素。
  
  ```csharp
  // Click a button with accessible name "log in"
  await page.Locator("role=button[name='log in']").ClickAsync();
  ```
  
  在 [我們的文件](./locators.mdx#locate-by-role).
- New `scale` 選項 in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) for smaller sized screenshots.
- New `caret` 選項 in [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 控制 text caret. Defaults to `"hide"`.
- We現在ship a designated .NET docker image `mcr.microsoft.com/playwright/dotnet`. 在 [我們的文件](./docker).

### 行為變更
- Playwright 現在透過 [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) API 支援大型檔案上傳（數百 MB）。

### 瀏覽器版本
- Chromium 101.0.4951.26
- Mozilla Firefox 98.0.2
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 100
- Microsoft Edge 100

## 版本 1.20

### Web-First 斷言

Playwright for .NET 1.20 引入了 [Web-First 斷言](./test-assertions).

Consider the following example:

```csharp
using System.Threading.Tasks;
using Microsoft.Playwright.NUnit;
using NUnit.Framework;

namespace PlaywrightTests;

[TestFixture]
public class ExampleTests : PageTest
{
    [Test]
    public async Task StatusBecomesSubmitted()
    {
        await Expect(Page.Locator(".status")).ToHaveTextAsync("Submitted");
    }
}
```

Playwright will be re-testing the node with the selector `.status` until fetched Node has the `"Submitted"` text. It will be re-fetching the node and checking it over and over, until the condition is met or until the timeout is reached. 您可以pass this timeout as an 選項.

在 [我們的文件](./test-assertions).

### 其他更新
- 新選項s用於方法[Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot), [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) 和 [ElementHandle.ScreenshotAsync()](/api/class-elementhandle.mdx#element-handle-screenshot):
  * 選項 `ScreenshotAnimations.Disabled` 將所有 CSS 動畫和轉場重置為一致狀態
  * 選項 `mask: Locator[]` 遮罩指定的元素，在其上方覆蓋粉色 `#FF00FF` 方框。
- [Locator.HighlightAsync()](/api/class-locator.mdx#locator-highlight)視覺化地顯示element(s)以便更輕鬆地debugging.

### 公告
- v1.20是最後一個接收receive WebKit update for macOS 10.15 Catalina. 請更新macOS以繼續使用latest & greatest WebKit!

### 瀏覽器版本
- Chromium 101.0.4921.0
- Mozilla Firefox 97.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 99
- Microsoft Edge 99

## 版本 1.19

### 重點
- Locator 現在支援 `has` 選項，確保它在內部包含另一個定位器：
  
  ```csharp
  await Page.Locator("article", new() { Has = Page.Locator(".highlight") }).ClickAsync();
  ```
  
  在[定位器文件](./api/class-locator#locator-locator)中閱讀更多
- 新的 [Locator.Page](/api/class-locator.mdx#locator-page)
- [Page.ScreenshotAsync()](/api/class-page.mdx#page-screenshot) 和 [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) 現在會自動隱藏閃爍的游標
- Playwright Codegen 現在會產生定位器和框架定位器

### 瀏覽器版本
- Chromium 100.0.4863.0
- Mozilla Firefox 96.0.1
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 98
- Microsoft Edge 98

## 版本 1.18

### 定位器改進
- [Locator.DragToAsync()](/api/class-locator.mdx#locator-drag-to)
- 每個定位器現在可以選擇性地依其包含的文字進行篩選：
  
  ```csharp
  await Page.Locator("li", new() { HasTextString = "My Item" })
            .Locator("button").click();
  ```
  
  在[定位器文件](./api/class-locator#locator-locator)中閱讀更多

### 新的 API 與變更
- [`AcceptDownloads`](./api/class-browser#browser-new-context-選項-accept-downloads) 選項現在預設為 `true`。
- [`Sources`](./api/class-tracing#tracing-start-選項-sources) 選項 to embed sources into traces.

### 瀏覽器版本
- Chromium 99.0.4812.0
- Mozilla Firefox 95.0
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 97
- Microsoft Edge 97

## 版本 1.17

### 框架定位器

Playwright 1.17 introduces [frame locators](./api/class-framelocator) - a locator to the iframe on the page. Frame locators capture the logic sufficient to retrieve the `iframe` and then locate elements in that iframe. Frame locators are strict by default, will wait for `iframe` to appear and 可以使用 in Web-First assertions.

![Graphics](https://user-images.githubusercontent.com/746130/142082759-2170db38-370d-43ec-8d41-5f9941f57d83.png)

框架定位器可以使用 [Page.FrameLocator()](/api/class-page.mdx#page-frame-locator) 或 [Locator.FrameLocator()](/api/class-locator.mdx#locator-frame-locator) 方法建立。

```csharp
var locator = page.FrameLocator("#my-frame").Locator("text=Submit");
await locator.ClickAsync();
```

在[我們的文件](./api/class-framelocator)閱讀更多。

### 追蹤檢視器更新

Playwright 追蹤檢視器現在**可在線上使用**，網址為 https://trace.playwright.dev！只需拖放您的 `trace.zip` 檔案即可檢查其內容。

> **NOTE**: trace files are not uploaded anywhere; [trace.playwright.dev](https://trace.playwright.dev) is a [progressive web application](https://web.dev/progressive-web-apps/) that processes traces locally.
- Playwright 測試追蹤現在預設包含原始碼（這些可以透過追蹤選項關閉）
- 追蹤檢視器現在顯示測試名稱
- 含有瀏覽器詳細資訊的新追蹤中繼資料標籤
- 快照現在有 URL 列

![image](https://user-images.githubusercontent.com/746130/141877831-29e37cd1-e574-4bd9-aab5-b13a463bb4ae.png)

### HTML Report Update
- HTML report 現在支援 dynamic filtering
- 報告現在是**單一靜態 HTML 檔案**，可透過電子郵件傳送或作為 slack 附件。

![image](https://user-images.githubusercontent.com/746130/141877402-e486643d-72c7-4db3-8844-ed2072c5d676.png)

### Ubuntu ARM64 支援與更多功能
- Playwright 現在支援 **Ubuntu 20.04 ARM64**。您現在可以在 Apple M1 的 Docker 內和 Raspberry Pi 上執行 Playwright 測試。
- 您現在可以使用 Playwright 在 Linux 上安裝穩定版本的 Edge：
  
  ```bash
  pwsh bin/Debug/netX/playwright.ps1 install msedge
  ```
  
### 新的 API
- Tracing 現在支援 a [`'title'`](./api/class-tracing#tracing-start-選項-title) 選項
- Page navigations support a new [`'commit'`](./api/class-page#page-goto) waiting 選項

## 版本 1.16

### 🎭 Playwright Library

#### Locator.WaitForAsync

等待定位器解析為具有給定狀態的單一元素。預設為 `state: 'visible'`。

```csharp
var orderSent = page.Locator("#order-sent");
orderSent.WaitForAsync();
```

在[Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for).

### 🎭 Playwright Trace Viewer
- run trace viewer with `pwsh bin/Debug/netX/playwright.ps1 show-trace` and drop trace files to the trace viewer PWA
- better visual attribution of action targets

在[Trace Viewer](./trace-viewer).

### 瀏覽器版本
- Chromium 97.0.4666.0
- Mozilla Firefox 93.0
- WebKit 15.4

此版本也對以下穩定頻道進行了測試：
- Google Chrome 94
- Microsoft Edge 94

## 版本 1.15

### 🖱️ Mouse Wheel

透過使用 [Mouse.WheelAsync()](/api/class-mouse.mdx#mouse-wheel)，您現在可以垂直或水平滾動。

### 📜 新的 Headers API

以前無法取得回應的多個標頭值。現在這是可能的，並提供了額外的輔助函數：
- [Request.AllHeadersAsync()](/api/class-request.mdx#request-all-headers)
- [Request.HeadersArrayAsync()](/api/class-request.mdx#request-headers-array)
- [Request.HeaderValueAsync()](/api/class-request.mdx#request-header-value)
- [Response.AllHeadersAsync()](/api/class-response.mdx#response-all-headers)
- [Response.HeadersArrayAsync()](/api/class-response.mdx#response-headers-array)
- [Response.HeaderValueAsync()](/api/class-response.mdx#response-header-value)
- [Response.HeaderValuesAsync()](/api/class-response.mdx#response-header-values)

### 🌈 Forced-Colors emulation

現在可以透過在 [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 中傳遞它或呼叫 [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media) 來模擬 `forced-colors` CSS 媒體功能。

### 新的 API
- [Page.RouteAsync()](/api/class-page.mdx#page-route) 接受新的 `times` 選項，以指定此路由應匹配多少次。
- [Page.SetCheckedAsync()](/api/class-page.mdx#page-set-checked) 和 [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) 被引入以設定the checked state of a checkbox.
- [Request.SizesAsync()](/api/class-request.mdx#request-sizes) 回傳 resource size information for given http request.
- [Tracing.StartChunkAsync()](/api/class-tracing.mdx#tracing-start-chunk) - Start a new trace chunk.
- [Tracing.StopChunkAsync()](/api/class-tracing.mdx#tracing-stop-chunk) - Stops a new trace chunk.

### Important ⚠
* ⬆ .NET Core Apps 2.1 are **no longer** supported for our CLI tooling. As of August 31st, 2021, .NET Core 2.1 is no [longer supported](https://devblogs.microsoft.com/dotnet/net-core-2-1-will-reach-end-of-support-on-august-21-2021/) and will not receive any security updates. We've decided to move the CLI forward and require .NET Core 3.1 as a minimum.

### 瀏覽器版本
- Chromium 96.0.4641.0
- Mozilla Firefox 92.0
- WebKit 15.0

## 版本 1.14

#### ⚡️ New "strict" mode

Selector ambiguity is a common problem in automation testing. **"strict" mode** ensures that your selector points to a single element and throws otherwise.

Set `setStrict(true)` in your action calls to opt in.

```csharp
// This will throw if you have more than one button!
await page.Locator("button", new() { Strict = true });
```

#### 📍 新的 [**Locators API**](./api/class-locator)

Locator represents a view to the element(s) on the page. It captures the logic sufficient to retrieve the element at any given moment.

The difference between the [Locator](./api/class-locator) 和 [ElementHandle](./api/class-elementhandle) is that the latter points to a particular element, while [Locator](./api/class-locator) captures the logic of how to retrieve that element.

Also, locators are **"strict" by default**!

```csharp
var locator = page.Locator("button");
await locator.ClickAsync();
```

在[文件](./api/class-locator)中了解更多。

#### 🧩 Experimental [**React**](./other-locators.mdx#react-locator) 和 [**Vue**](./other-locators.mdx#vue-locator) selector engines

React 和 Vue 選擇器允許按組件名稱和/或屬性值選擇元素。語法與[屬性選擇器](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors)非常相似，並支援所有屬性選擇器運算子。

```csharp
await page.Locator("_react=SubmitButton[enabled=true]").ClickAsync();
await page.Locator("_vue=submit-button[enabled=true]").ClickAsync();
```

在 [react 選擇器文件](./other-locators.mdx#react-locator) 和 [vue 選擇器文件](./other-locators.mdx#vue-locator) 中了解更多。

#### ✨ New [**`nth`**](./other-locators.mdx#n-th-element-locator) 和 [**`visible`**](./other-locators.mdx#css-matching-only-visible-elements) selector engines
- [`nth`](./other-locators.mdx#n-th-element-locator) selector engine is equivalent to the `:nth-match` pseudo class, but could be combined with other selector engines.
- [`visible`](./other-locators.mdx#css-matching-only-visible-elements) selector engine is equivalent to the `:visible` pseudo class, but could be combined with other selector engines.

```csharp
// select the first button among all buttons
await button.ClickAsync("button >> nth=0");
// or if you are using locators, you can use First, Nth() and Last
await page.Locator("button").First.ClickAsync();

// click a visible button
await button.ClickAsync("button >> visible=true");
```

### 瀏覽器版本
- Chromium 94.0.4595.0
- Mozilla Firefox 91.0
- WebKit 15.0

## 版本 1.13

#### Playwright
- **🖖 Programmatic drag-and-drop support** via the [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) API.
- **🔎 Enhanced HAR**具有請求和回應的主體大小. 透過 `recordHar` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context). 使用

#### 工具
- Playwright Trace Viewer現在shows parameters, returned values and `console.log()` calls.

#### 新增與重新編寫的指南
- [Intro](./intro.mdx)
- [Authentication](./auth.mdx)

#### 瀏覽器版本
- Chromium 93.0.4576.0
- Mozilla Firefox 90.0
- WebKit 14.2

#### 新的 Playwright API
- new `baseURL` 選項 in [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) 和 [Browser.NewPageAsync()](/api/class-browser.mdx#browser-new-page)
- [Response.SecurityDetailsAsync()](/api/class-response.mdx#response-security-details) 和 [Response.ServerAddrAsync()](/api/class-response.mdx#response-server-addr)
- [Page.DragAndDropAsync()](/api/class-page.mdx#page-drag-and-drop) 和 [Frame.DragAndDropAsync()](/api/class-frame.mdx#frame-drag-and-drop)
- [Download.CancelAsync()](/api/class-download.mdx#download-cancel)
- [Page.InputValueAsync()](/api/class-page.mdx#page-input-value), [Frame.InputValueAsync()](/api/class-frame.mdx#frame-input-value) 和 [ElementHandle.InputValueAsync()](/api/class-elementhandle.mdx#element-handle-input-value)
- new `force` 選項 in [Page.FillAsync()](/api/class-page.mdx#page-fill), [Frame.FillAsync()](/api/class-frame.mdx#frame-fill), 和 [ElementHandle.FillAsync()](/api/class-elementhandle.mdx#element-handle-fill)
- new `force` 選項 in [Page.SelectOptionAsync()](/api/class-page.mdx#page-select-選項), [Frame.SelectOptionAsync()](/api/class-frame.mdx#frame-select-選項), 和 [ElementHandle.SelectOptionAsync()](/api/class-elementhandle.mdx#element-handle-select-選項)

## 版本 1.12

#### 重點
- Playwright for .NET v1.12 is現在stable!
- Ships with the [codegen](./codegen.mdx) 和 [trace viewer](./trace-viewer.mdx) tools out-of-the-box

#### 瀏覽器版本
- Chromium 93.0.4530.0
- Mozilla Firefox 89.0
- WebKit 14.2

此版本也對以下穩定頻道進行了測試：
- Google Chrome 91
- Microsoft Edge 91


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
