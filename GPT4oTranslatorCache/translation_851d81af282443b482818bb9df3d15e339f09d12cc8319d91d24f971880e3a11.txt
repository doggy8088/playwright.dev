* 使用 [locator.or()](/api/class-locator.mdx#locator-or) 建立一個符合任一定位器的定位器。考慮一個情境，你想點擊 "New email" 按鈕，但有時會彈出安全設定對話框。在這種情況下，你可以等待 "New email" 按鈕或對話框並相應地操作：

  ```js
  const newEmail = page.getByRole('button', { name: 'New email' });
  const dialog = page.getByText('Confirm security settings');
  await expect(newEmail.or(dialog)).toBeVisible();
  if (await dialog.isVisible())
    await page.getByRole('button', { name: 'Dismiss' }).click();
  await newEmail.click();
  ```

* 在 [locator.filter()](/api/class-locator.mdx#locator-filter) 中使用新的選項 `hasNot` 和 `hasNotText` 來找到**不符合**某些條件的元素。

  ```js
  const rowLocator = page.locator('tr');
  await rowLocator
      .filter({ hasNotText: 'text in column 1' })
      .filter({ hasNot: page.getByRole('button', { name: 'column 2 button' }) })
      .screenshot();
  ```

* 使用新的 web-first 斷言 [expect(locator).toBeAttached()](https://api/class-locatorassertions.mdx#locator-assertions-to-be-attached) 確保元素存在於頁面的 DOM 中。不要與 [expect(locator).toBeVisible()](https://api/class-locatorassertions.mdx#locator-assertions-to-be-visible) 混淆，後者確保元素既已附加又可見。