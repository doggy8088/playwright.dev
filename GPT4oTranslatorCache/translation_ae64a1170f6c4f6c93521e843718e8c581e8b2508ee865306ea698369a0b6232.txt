* 使用 [Locator.Or()](/api/class-locator.mdx#locator-or) 建立一個匹配任意兩個定位器的定位器。考慮一個情境，你想點擊“New email”按鈕，但有時會彈出安全設定對話框。在這種情況下，你可以等待“New email”按鈕或對話框，並相應地行動：
  
  ```csharp
  var newEmail = Page.GetByRole(AriaRole.Button, new() { Name = "New email" });
  var dialog = Page.GetByText("Confirm security settings");
  await Expect(newEmail.Or(dialog)).ToBeVisibleAsync();
  if (await dialog.IsVisibleAsync())
    await Page.GetByRole(AriaRole.Button, new() { Name = "Dismiss" }).ClickAsync();
  await newEmail.ClickAsync();
  ```
  
* 在 [Locator.Filter()](/api/class-locator.mdx#locator-filter) 中使用新的選項 `hasNot` 和 `hasNotText` 來找到**不匹配**某些條件的元素。
  
  ```csharp
  var rowLocator = Page.Locator("tr");
  await rowLocator
      .Filter(new() { HasNotText = "text in column 1" })
      .Filter(new() { HasNot = Page.GetByRole(AriaRole.Button, new() { Name = "column 2 button" })})
      .ScreenshotAsync();
  ```
  
* 使用新的 web-first 斷言 [Expect(Locator).ToBeAttachedAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-be-attached) 來確保元素存在於頁面的 DOM 中。不要與 [Expect(Locator).ToBeVisibleAsync](https://api/class-locatorassertions.mdx#locator-assertions-to-be-visible) 混淆，後者確保元素既已附加又可見。