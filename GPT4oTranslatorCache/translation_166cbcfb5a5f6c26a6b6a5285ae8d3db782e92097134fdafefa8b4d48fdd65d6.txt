* 使用 [locator.or_()](/api/class-locator#locator-or) 建立一個匹配任意兩個定位器的定位器。考慮一個情景，你想點擊 "New email" 按鈕，但有時會彈出一個安全設定對話框。在這種情況下，你可以等待 "New email" 按鈕或對話框，並相應地操作：

  ```python
  new_email = page.get_by_role("button", name="New email")
  dialog = page.get_by_text("Confirm security settings")
  expect(new_email.or_(dialog)).is_visible()
  if (dialog.is_visible()):
    page.get_by_role("button", name="Dismiss").click()
  new_email.click()
  ```

* 在 [locator.filter()](/api/class-locator#locator-filter) 中使用新的選項 `has_not` 和 `has_not_text` 來查找**不匹配**某些條件的元素。

  ```python
  row_locator = page.locator("tr")
  row_locator.filter(has_not_text="text in column 1").filter(
      has_not=page.get_by_role("button", name="column 2 button")
  ).screenshot()
  ```

* 使用新的 web-first 斷言 [expect(locator).to_be_attached()](/api/class-locatorassertions#locator-assertions-to-be-attached) 確保元素存在於頁面的 DOM 中。不要與 [expect(locator).to_be_visible()](/api/class-locatorassertions#locator-assertions-to-be-visible) 混淆，後者確保元素既附加又可見。