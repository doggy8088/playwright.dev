---
id: locators
title: "定位器"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';
import ProgressiveImage from '@theme/ProgressiveImage';

## 簡介

[定位器][Locator] 是 Playwright 自動等待與可重試能力的核心。簡而言之，定位器代表能在任意時刻於頁面上找到元素的方法。

### 快速指南

以下是建議優先使用的內建定位器：
- [page.get_by_role()](#locate-by-role)：透過明確與隱含的無障礙屬性定位。
- [page.get_by_text()](#locate-by-text)：透過文字內容定位。
- [page.get_by_label()](#locate-by-label)：透過關聯標籤文字定位表單控制項。
- [page.get_by_placeholder()](#locate-by-placeholder)：透過 placeholder 提示文字定位輸入框。
- [page.get_by_alt_text()](#locate-by-alt-text)：透過替代文字定位元素（通常是圖片）。
- [page.get_by_title()](#locate-by-title)：透過 title 屬性定位元素。
- [page.get_by_test_id()](#locate-by-test-id)：透過 `data-testid` 屬性定位元素（可自訂其它屬性）。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("User Name").fill("John")

page.get_by_label("Password").fill("secret-password")

page.get_by_role("button", name="Sign in").click()

expect(page.get_by_text("Welcome, John!")).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("User Name").fill("John")

await page.get_by_label("Password").fill("secret-password")

await page.get_by_role("button", name="Sign in").click()

await expect(page.get_by_text("Welcome, John!")).to_be_visible()
```

</TabItem>
</Tabs>

## 定位元素

Playwright 提供多種內建定位器。為了讓測試更具韌性，建議優先使用面向使用者的屬性與明確契約，例如 [page.get_by_role()](/api/class-page.mdx#page-get-by-role)。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<button>Sign in</button>
</div>

```html
<button>Sign in</button>
```
</HTMLCard>

透過名稱為「Sign in」的 `button` 角色來定位該元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button", name="Sign in").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button", name="Sign in").click()
```

</TabItem>
</Tabs>

:::note

使用[程式碼產生器](./codegen.mdx)來產生定位器，然後依需求編輯。
:::

每次使用定位器執行動作時，都會在頁面上定位到最新的 DOM 元素。以下範例中，底層 DOM 會定位兩次：每個動作前各一次。這代表如果在兩次呼叫之間因重新渲染導致 DOM 發生變化，定位器會對應到新的元素並予以使用。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.get_by_role("button", name="Sign in")

locator.hover()
locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.get_by_role("button", name="Sign in")

await locator.hover()
await locator.click()
```

</TabItem>
</Tabs>

請注意，所有建立定位器的方法，例如 [page.get_by_label()](/api/class-page.mdx#page-get-by-label)，同樣也能在 [Locator] 與 [FrameLocator] 類別上使用，因此你可以串接它們以逐步縮小定位範圍。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.frame_locator("my-frame").get_by_role("button", name="Sign in")

locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.frame_locator("#my-frame").get_by_role("button", name="Sign in")

await locator.click()
```

</TabItem>
</Tabs>

### 透過角色定位

[page.get_by_role()](/api/class-page.mdx#page-get-by-role) 反映使用者與輔助技術如何感知頁面，例如某元素是按鈕或核取方塊。使用角色定位時，通常也應該傳入可存取名稱，讓定位器能精準鎖定特定元素。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
</div>

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```
</HTMLCard>

你可以透過元素的隱含角色來定位每個元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

page.get_by_role("checkbox", name="Subscribe").check()

page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

await page.get_by_role("checkbox", name="Subscribe").check()

await page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
</Tabs>

角色定位器涵蓋[按鈕、核取方塊、標題、連結、清單、表格等](https://www.w3.org/TR/html-aria/#docconformance)，並遵循 W3C 針對 [ARIA 角色](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA 屬性](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) 與[可存取名稱](https://w3c.github.io/accname/#dfn-accessible-name)的規範。請注意，許多 HTML 元素如 `<button>` 具有[隱含角色定義](https://w3c.github.io/html-aam/#html-element-role-mappings)，可被角色定位器辨識。

同時要注意，角色定位器並非用來取代無障礙稽核與相容性測試，而是能提供遵循 ARIA 準則的早期回饋。

:::note[何時使用角色定位器]

我們建議優先使用角色定位器來定位元素，因為這最貼近使用者與輔助技術感知頁面的方式。
:::

### 透過標籤定位

多數表單控制項通常有對應的標籤，可方便地與表單互動。此時可使用 [page.get_by_label()](/api/class-page.mdx#page-get-by-label) 透過關聯標籤文字來定位控制項。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<label>Password <input type="password" /></label>

</div>

```html
<label>Password <input type="password" /></label>

```
</HTMLCard>

你可以先透過標籤文字定位輸入框，然後填值：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("Password").fill("secret")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("Password").fill("secret")
```

</TabItem>
</Tabs>

:::note[何時使用標籤定位器]

在定位表單欄位時使用本定位器。
:::

### 透過 placeholder 定位

輸入框可能帶有 placeholder 屬性，提示使用者應輸入的值。你可以使用 [page.get_by_placeholder()](/api/class-page.mdx#page-get-by-placeholder) 來定位此類輸入框。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<input type="email" placeholder="name@example.com" />
</div>

```html
<input type="email" placeholder="name@example.com" />
```
</HTMLCard>

你可以先透過 placeholder 文字定位輸入框，然後填值：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
</Tabs>

:::note[何時使用 placeholder 定位器]

當定位沒有標籤但有 placeholder 文字的表單元素時使用本定位器。
:::

### 透過文字定位

依元素所含文字來尋找元素。使用 [page.get_by_text()](/api/class-page.mdx#page-get-by-text) 時，可以以子字串、完全相符或正規表示式進行比對。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<span>Welcome, John</span>
</div>

```html
<span>Welcome, John</span>
```
</HTMLCard>

你可以以其包含的文字來定位元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text("Welcome, John")).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_text("Welcome, John")).to_be_visible()
```

</TabItem>
</Tabs>

設定完全相符：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text("Welcome, John", exact=True)).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_text("Welcome, John", exact=True)).to_be_visible()
```

</TabItem>
</Tabs>

使用正規表示式比對：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text(re.compile("welcome, john", re.IGNORECASE))).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_text(re.compile("welcome, john", re.IGNORECASE))
).to_be_visible()
```

</TabItem>
</Tabs>

:::note

以文字比對時一律會正規化空白，即使在完全相符的情況下也是如此。例如會把多個空格合併為一個、將換行轉成空格，並忽略前後空白。
:::

:::note[何時使用文字定位器]
建議使用文字定位器尋找非互動元素，例如 `div`、`span`、`p` 等。對於 `button`、`a`、`input` 等互動元素，請使用[角色定位器](#locate-by-role)。
:::

你也可以[依文字過濾](#filter-by-text)，在從清單中尋找特定項目時相當實用。

### 透過替代文字定位

所有圖片都應有描述圖片內容的 `alt` 屬性。你可以使用 [page.get_by_alt_text()](/api/class-page.mdx#page-get-by-alt-text) 透過替代文字來定位圖片。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
</div>

```html
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
```
</HTMLCard>

你可以透過替代文字定位圖片後進行點擊：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_alt_text("playwright logo").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_alt_text("playwright logo").click()
```

</TabItem>
</Tabs>

:::note[何時使用替代文字定位器]

當你的元素支援替代文字（例如 `img` 與 `area` 元素）時使用本定位器。
:::

### 透過標題定位

使用 [page.get_by_title()](/api/class-page.mdx#page-get-by-title) 透過 title 屬性定位元素。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<span title='Issues count'>25 issues</span>
</div>

```html
<span title='Issues count'>25 issues</span>
```
</HTMLCard>

你可以先透過標題文字定位，然後檢查問題數量：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
</Tabs>

:::note[何時使用標題定位器]

當你的元素具有 `title` 屬性時使用本定位器。
:::

### 透過測試 ID 定位

透過測試 ID 測試是最具韌性的方式，因為即使文字或屬性的角色改變，測試仍能通過。QA 與開發者應定義明確的測試 ID，並使用 [page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id) 來查詢。不過以測試 ID 測試並非面向使用者；若角色或文字值對你很重要，請考慮使用[角色](#locate-by-role)或[文字定位器](#locate-by-text)等面向使用者的定位方式。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<button data-testid="directions">Itinéraire</button>
</div>

```html
<button data-testid="directions">Itinéraire</button>
```
</HTMLCard>

你可以透過測試 ID 定位元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

:::note[何時使用測試 ID 定位器]

當你採用測試 ID 方法論，或無法透過[角色](#locate-by-role)或[文字](#locate-by-text)定位時，也可以使用測試 ID。
:::

#### 設定自訂測試 ID 屬性

預設情況下，[page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id) 會以 `data-testid` 屬性來定位元素，但你可以在測試設定中或透過呼叫 [selectors.set_test_id_attribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) 來自訂。

設定以自訂的資料屬性作為測試 ID：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
playwright.selectors.set_test_id_attribute("data-pw")
```

</TabItem>
<TabItem value="async">

```py
playwright.selectors.set_test_id_attribute("data-pw")
```

</TabItem>
</Tabs>

在你的 HTML 中，現在可以使用 `data-pw` 作為測試 ID，而非預設的 `data-testid`：

<HTMLCard>
<div>
<button data-pw="directions">Itinéraire</button>
</div>

```html
<button data-pw="directions">Itinéraire</button>
```
</HTMLCard>

接著便可像平常一樣定位該元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

### 使用 CSS 或 XPath 定位

若你確實必須使用 CSS 或 XPath 定位器，可以使用 [page.locator()](/api/class-page.mdx#page-locator) 建立接受選擇器的定位器，描述如何在頁面中尋找元素。Playwright 支援 CSS 與 XPath 選擇器；若省略 `css=` 或 `xpath=` 前綴，會自動偵測選擇器類型。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator("css=button").click()
page.locator("xpath=//button").click()

page.locator("button").click()
page.locator("//button").click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator("css=button").click()
await page.locator("xpath=//button").click()

await page.locator("button").click()
await page.locator("//button").click()
```

</TabItem>
</Tabs>

XPath 與 CSS 選擇器常與 DOM 結構或實作緊密耦合，當 DOM 結構改變時，這些選擇器可能失效。下面這類冗長的 CSS 或 XPath 鏈結就是導致測試不穩定的「不良實務」：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator(
    "#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input"
).click()

page.locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input').click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator(
    "#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input"
).click()

await page.locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input').click()
```

</TabItem>
</Tabs>

:::note[何時使用此作法]

不建議使用 CSS 與 XPath，因為 DOM 經常變更會導致測試不具韌性。請嘗試設計更貼近使用者感知的定位器，例如[角色定位器](#locate-by-role)，或使用測試 ID [定義明確的測試契約](#locate-by-test-id)。
:::

## 在 Shadow DOM 中定位

Playwright 中的定位器預設即可作用於 Shadow DOM 中的元素。以下為例外情況：
- 透過 XPath 定位不會穿透 shadow root。
- 不支援 [Closed-mode shadow roots](https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#parameters)。

考慮下列自訂 Web Component 範例：

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

你可以如同沒有 shadow root 一樣進行定位。

要點擊 `<div>Details</div>`：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_text("Details").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_text("Details").click()
```

</TabItem>
</Tabs>

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

要點擊 `<x-details>`：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator("x-details", has_text="Details").click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator("x-details", has_text="Details").click()
```

</TabItem>
</Tabs>

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

要確保 `<x-details>` 包含文字 "Details"：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.locator("x-details")).to_contain_text("Details")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.locator("x-details")).to_contain_text("Details")
```

</TabItem>
</Tabs>

## 篩選定位器

考慮以下 DOM 結構：我們想點擊第二張產品卡的購買按鈕。可以用數種方式來篩選定位器，得到正確的那一個。

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

### 依文字篩選

可使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 依文字篩選定位器。它會在元素內部（可能在後代元素中）搜尋特定字串，且不區分大小寫。也可傳入正規表示式。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text="Product 2").get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text="Product 2").get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
</Tabs>

使用正規表示式：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text=re.compile("Product 2")).get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text=re.compile("Product 2")).get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
</Tabs>

### 依「沒有某段文字」篩選

或是依「不包含」某段文字來篩選：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# 5 in-stock items
expect(page.get_by_role("listitem").filter(has_not_text="Out of stock")).to_have_count(5)
```

</TabItem>
<TabItem value="async">

```py
# 5 in-stock items
await expect(page.get_by_role("listitem").filter(has_not_text="Out of stock")).to_have_count(5)
```

</TabItem>
</Tabs>

### 依子/後代元素篩選

定位器提供選項，僅選取擁有（或沒有）符合另一個定位器之後代的元素。因此你可以透過任一定位器來篩選，例如 [locator.get_by_role()](/api/class-locator.mdx#locator-get-by-role)、[locator.get_by_test_id()](/api/class-locator.mdx#locator-get-by-test-id)、[locator.get_by_text()](/api/class-locator.mdx#locator-get-by-text) 等。

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(
    has=page.get_by_role("heading", name="Product 2")
).get_by_role("button", name="Add to cart").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(
    has=page.get_by_role("heading", name="Product 2")
).get_by_role("button", name="Add to cart").click()
```

</TabItem>
</Tabs>

我們也能針對產品卡做斷言以確保只有一個：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

篩選用的定位器「必須」相對於原始定位器，並從原始定位器的配對開始查詢，而非從文件根節點開始。因此以下範例不會生效，因為篩選定位器從 `<ul>` 清單元素開始配對，該元素在原先 `<li>` 清單項目之外：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# ✖ WRONG
expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("list").get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
# ✖ WRONG
await expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("list").get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

### 依「沒有子/後代元素」篩選

也可以依「沒有」內部匹配元素來篩選：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(
    page.get_by_role("listitem").filter(
        has_not=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_role("listitem").filter(
        has_not=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

請注意，內部定位器是從外部定位器開始配對，而非從文件根節點。

## 定位器運算元

### 在定位器內部比對

你可以串接會建立定位器的方法，例如 [page.get_by_text()](/api/class-page.mdx#page-get-by-text) 或 [locator.get_by_role()](/api/class-locator.mdx#locator-get-by-role)，以將搜尋範圍縮小到頁面的特定部分。

以下範例中，我們先以 `listitem` 角色建立名為 product 的定位器，然後依文字篩選。之後再用這個 product 定位器取得按鈕角色並點擊，最後以斷言確保只剩一個包含文字「Product 2」的產品：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
product = page.get_by_role("listitem").filter(has_text="Product 2")

product.get_by_role("button", name="Add to cart").click()
```

</TabItem>
<TabItem value="async">

```py
product = page.get_by_role("listitem").filter(has_text="Product 2")

await product.get_by_role("button", name="Add to cart").click()
```

</TabItem>
</Tabs>

你也可以將兩個定位器串接，例如在特定對話框中尋找「Save」按鈕：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
save_button = page.get_by_role("button", name="Save")
# ...
dialog = page.get_by_test_id("settings-dialog")
dialog.locator(save_button).click()
```

</TabItem>
<TabItem value="async">

```py
save_button = page.get_by_role("button", name="Save")
# ...
dialog = page.get_by_test_id("settings-dialog")
await dialog.locator(save_button).click()
```

</TabItem>
</Tabs>

### 同時比對兩個定位器

[locator.and_()](/api/class-locator.mdx#locator-and) 會藉由再匹配一個定位器來縮小既有定位器的範圍。例如可以結合 [page.get_by_role()](/api/class-page.mdx#page-get-by-role) 與 [page.get_by_title()](/api/class-page.mdx#page-get-by-title)，同時依角色與標題比對。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
button = page.get_by_role("button").and_(page.getByTitle("Subscribe"))
```

</TabItem>
<TabItem value="async">

```py
button = page.get_by_role("button").and_(page.getByTitle("Subscribe"))
```

</TabItem>
</Tabs>

### 在多個候選定位器中擇一比對

若你要鎖定兩個或以上元素其中之一，但不確定會是哪一個，可用 [locator.or_()](/api/class-locator.mdx#locator-or) 建立可比對任一（或兩者）替代方案的定位器。

例如，想點擊「New email」按鈕，但有時會出現安全性設定對話框。此時可以等待「New email」按鈕或對話框，並依情況採取行動。

:::note

若「New email」按鈕與安全性對話框同時出現，「or」定位器會同時比對兩者，可能會拋出[嚴格模式違規](#strictness)錯誤。此時可改用 [locator.first](/api/class-locator.mdx#locator-first) 只比對其中一個。
:::

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
new_email = page.get_by_role("button", name="New")
dialog = page.get_by_text("Confirm security settings")
expect(new_email.or_(dialog).first).to_be_visible()
if (dialog.is_visible()):
  page.get_by_role("button", name="Dismiss").click()
new_email.click()
```

</TabItem>
<TabItem value="async">

```py
new_email = page.get_by_role("button", name="New")
dialog = page.get_by_text("Confirm security settings")
await expect(new_email.or_(dialog).first).to_be_visible()
if (await dialog.is_visible()):
  await page.get_by_role("button", name="Dismiss").click()
await new_email.click()
```

</TabItem>
</Tabs>

### 只比對可見元素

:::note

通常更好的做法是找出[更可靠](./locators.mdx#quick-guide)且能唯一識別該元素的方式，而不是檢查可見性。
:::

Consider a page with two buttons, the first invisible and the second [visible](./actionability.mdx#visible).

```html
<button style='display: none'>Invisible</button>
<button>Visible</button>
```

* 以下會同時找到兩個按鈕並拋出[嚴格性](./locators.mdx#strictness)違規錯誤：
  <Tabs
    groupId="python-flavor"
    defaultValue="sync"
    values={[
      {label: 'Sync', value: 'sync'},
      {label: 'Async', value: 'async'}
    ]
  }>
  <TabItem value="sync">
  
  ```py
  page.locator("button").click()
  ```
  
  </TabItem>
  <TabItem value="async">
  
  ```py
  await page.locator("button").click()
  ```
  
  </TabItem>
  </Tabs>
* 以下只會找到第二個（因為它是可見的），然後點擊它。
  
  <Tabs
    groupId="python-flavor"
    defaultValue="sync"
    values={[
      {label: 'Sync', value: 'sync'},
      {label: 'Async', value: 'async'}
    ]
  }>
  <TabItem value="sync">
  
  ```py
  page.locator("button").filter(visible=True).click()
  ```
  
  </TabItem>
  <TabItem value="async">
  
  ```py
  await page.locator("button").filter(visible=True).click()
  ```
  
  </TabItem>
  </Tabs>

## 清單（Lists）

### 計算清單中的項目數

你可以對定位器進行斷言以計算清單中的項目數量。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

使用數量斷言確認清單有 3 個項目：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("listitem")).to_have_count(3)
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("listitem")).to_have_count(3)
```

</TabItem>
</Tabs>

### 斷言清單中所有文字

你可以對定位器進行斷言以找出清單中的所有文字。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

使用 [expect(locator).to_have_text()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) 確保清單包含「apple」、「banana」與「orange」：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("listitem")).to_have_text(["apple", "banana", "orange"])
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("listitem")).to_have_text(["apple", "banana", "orange"])
```

</TabItem>
</Tabs>

### 取得特定項目

有許多方法可以取得清單中的特定項目。

#### 透過文字取得

使用 [page.get_by_text()](/api/class-page.mdx#page-get-by-text) 依文字內容定位清單中的元素，然後點擊它。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

依文字內容定位並點擊：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_text("orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_text("orange").click()
```

</TabItem>
</Tabs>

#### 依文字篩選

使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 來定位清單中的特定項目。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

先以「listitem」角色定位項目，再依文字「orange」篩選並點擊：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text="orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text="orange").click()
```

</TabItem>
</Tabs>

#### 透過測試 ID 取得

使用 [page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id) 來定位清單中的元素。若你尚未有測試 ID，可能需要修改 HTML 來加入。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
</div>

```html
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
```
</HTMLCard>

以測試 ID「orange」定位並點擊：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("orange").click()
```

</TabItem>
</Tabs>

#### 透過序號取得第 N 個

若你有一份相同元素的清單，而且唯一可區分的方式是順序，可以用 [locator.first](/api/class-locator.mdx#locator-first)、[locator.last](/api/class-locator.mdx#locator-last) 或 [locator.nth()](/api/class-locator.mdx#locator-nth) 選取特定元素。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
banana = page.get_by_role("listitem").nth(1)
```

</TabItem>
<TabItem value="async">

```py
banana = await page.get_by_role("listitem").nth(1)
```

</TabItem>
</Tabs>

然而此法需謹慎使用。頁面經常會改變，定位器可能會指向與預期完全不同的元素。建議改為設計能通過[嚴格性條件](#strictness)的唯一定位器。

### 串接多重篩選

當元素之間同時具有各種相似性時，可使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 來選出正確元素，並可串接多個篩選器以縮小選取範圍。

例如，考慮以下 DOM 結構：

<HTMLCard>
<div>
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
```
</HTMLCard>

擷取同時包含「Mary」與「Say goodbye」的那一列螢幕截圖：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
row_locator = page.get_by_role("listitem")

row_locator.filter(has_text="Mary").filter(
    has=page.get_by_role("button", name="Say goodbye")
).screenshot(path="screenshot.png")
```

</TabItem>
<TabItem value="async">

```py
row_locator = page.get_by_role("listitem")

await row_locator.filter(has_text="Mary").filter(
    has=page.get_by_role("button", name="Say goodbye")
).screenshot(path="screenshot.png")
```

</TabItem>
</Tabs>

現在你的專案根目錄中應該會有一個 "screenshot.png" 檔案。

### 罕見使用情境

#### 對清單中每個元素做些事情

遍歷元素：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
for row in page.get_by_role("listitem").all():
    print(row.text_content())
```

</TabItem>
<TabItem value="async">

```py
for row in await page.get_by_role("listitem").all():
    print(await row.text_content())
```

</TabItem>
</Tabs>

使用一般 for 迴圈遍歷：

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
rows = page.get_by_role("listitem")
count = rows.count()
for i in range(count):
    print(rows.nth(i).text_content())
```

</TabItem>
<TabItem value="async">

```py
rows = page.get_by_role("listitem")
count = await rows.count()
for i in range(count):
    print(await rows.nth(i).text_content())
```

</TabItem>
</Tabs>

#### 在頁面中執行評估

[locator.evaluate_all()](/api/class-locator.mdx#locator-evaluate-all) 內的程式碼會在頁面中執行，你可以在那裡呼叫任何 DOM API。

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
rows = page.get_by_role("listitem")
texts = rows.evaluate_all("list => list.map(element => element.textContent)")
```

</TabItem>
<TabItem value="async">

```py
rows = page.get_by_role("listitem")
texts = await rows.evaluate_all("list => list.map(element => element.textContent)")
```

</TabItem>
</Tabs>

## 嚴格性（Strictness）

定位器具備嚴格性。也就是說，所有需要對應到目標 DOM 元素的定位器操作，若有多個元素符合就會拋出例外。例如，若 DOM 中有數個按鈕，下列呼叫會拋出例外：

#### 當符合多於一個元素時會拋出錯誤

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").click()
```

</TabItem>
</Tabs>

另一方面，Playwright 能理解你執行的是多元素操作，因此當定位器解析為多個元素時，以下呼叫完全沒有問題：

#### 可在多元素情況下正常運作

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button").count()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").count()
```

</TabItem>
</Tabs>

你可以明確地跳過嚴格性檢查，透過 [locator.first](/api/class-locator.mdx#locator-first)、[locator.last](/api/class-locator.mdx#locator-last) 與 [locator.nth()](/api/class-locator.mdx#locator-nth) 指示 Playwright 在多個元素符合時要使用哪一個。這些方法「不建議」使用，因為當頁面變更時，Playwright 可能會點擊非預期元素。建議遵循上方最佳實務，建立能唯一識別目標元素的定位器。

## 更多定位器

較少使用的定位器請參考[其它定位器](./other-locators.mdx)指南。


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/python/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
