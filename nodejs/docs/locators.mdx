---
id: locators
title: "定位器"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';
import ProgressiveImage from '@theme/ProgressiveImage';

## 簡介

[定位器][Locator]是 Playwright 自動等待和重試能力的核心部分。簡而言之，定位器代表在頁面上任何時刻尋找元素的方法。

### 快速指南

這些是建議的內建定位器。
- [page.getByRole()](#locate-by-role) 使用明確和隱含的無障礙屬性定位。
- [page.getByText()](#locate-by-text) 使用文字內容定位。
- [page.getByLabel()](#locate-by-label) 使用關聯標籤的文字定位表單控制項。
- [page.getByPlaceholder()](#locate-by-placeholder) 使用預留位置文字定位輸入欄位。
- [page.getByAltText()](#locate-by-alt-text) 使用替代文字定位元素，通常是圖片。
- [page.getByTitle()](#locate-by-title) 使用 title 屬性定位元素。
- [page.getByTestId()](#locate-by-test-id) 基於 `data-testid` 屬性定位元素（可設定其他屬性）。

```js
await page.getByLabel('User Name').fill('John');

await page.getByLabel('Password').fill('secret-password');

await page.getByRole('button', { name: 'Sign in' }).click();

await expect(page.getByText('Welcome, John!')).toBeVisible();
```

## 定位元素

Playwright 提供多種內建定位器。為了讓測試更具彈性，我們建議優先使用面向使用者的屬性和明確契約，如 [page.getByRole()](/api/class-page.mdx#page-get-by-role)。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<button>Sign in</button>
</div>

```html
<button>Sign in</button>
```
</HTMLCard>

透過名稱為 "Sign in" 的 `button` 角色定位元素。

```js
await page.getByRole('button', { name: 'Sign in' }).click();
```

:::note
使用[程式碼產生器](./codegen.mdx)產生定位器，然後依需要進行編輯。
:::

每次使用定位器執行動作時，都會在頁面中定位到最新的 DOM 元素。在下面的程式碼片段中，底層的 DOM 元素會被定位兩次，每個動作之前各一次。這意味著如果 DOM 因為重新渲染而在呼叫之間發生改變，將會使用對應定位器的新元素。

```js
const locator = page.getByRole('button', { name: 'Sign in' });

await locator.hover();
await locator.click();
```

請注意，所有建立定位器的方法，如 [page.getByLabel()](/api/class-page.mdx#page-get-by-label)，也可在 [Locator] 和 [FrameLocator] 類別上使用，因此您可以鏈接它們並反覆縮小定位器範圍。

```js
const locator = page
    .frameLocator('#my-frame')
    .getByRole('button', { name: 'Sign in' });

await locator.click();
```

### 透過角色定位

[page.getByRole()](/api/class-page.mdx#page-get-by-role) 定位器反映使用者和輔助技術如何認知頁面，例如某個元素是按鈕還是核取方塊。透過角色定位時，通常也應該傳遞可存取名稱，以便定位器精確指向特定元素。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
</div>

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```
</HTMLCard>

您可以透過隱含角色定位每個元素：

```js
await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();

await page.getByRole('checkbox', { name: 'Subscribe' }).check();

await page.getByRole('button', { name: /submit/i }).click();
```

角色定位器包括[按鈕、核取方塊、標題、連結、清單、表格等等](https://www.w3.org/TR/html-aria/#docconformance)，並遵循 [ARIA 角色](https://www.w3.org/TR/wai-aria-1.2/#roles)、[ARIA 屬性](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes)和[可存取名稱](https://w3c.github.io/accname/#dfn-accessible-name)的 W3C 規範。請注意，許多 HTML 元素如 `<button>` 都有[隱含定義的角色](https://w3c.github.io/html-aam/#html-element-role-mappings)，可被角色定位器識別。

請注意，角色定位器**不能取代**無障礙稽核和符合性測試，而是提供關於 ARIA 指引的早期回饋。

:::note[何時使用角色定位器]

我們建議優先使用角色定位器來定位元素，因為這是最接近使用者和輔助技術感知頁面的方式。
:::

### 透過標籤定位

大多數表單控制項通常都有專用標籤，可以方便地用來與表單互動。在這種情況下，您可以使用 [page.getByLabel()](/api/class-page.mdx#page-get-by-label) 透過其關聯標籤定位控制項。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<label>Password <input type="password" /></label>

</div>

```html
<label>Password <input type="password" /></label>

```
</HTMLCard>

您可以透過標籤文字定位輸入欄位後填入：

```js
await page.getByLabel('Password').fill('secret');
```

:::note[何時使用標籤定位器]
在定位表單欄位時使用此定位器。
:::

### 透過預留位置定位

輸入欄位可能有預留位置屬性來提示使用者應該輸入什麼值。您可以使用 [page.getByPlaceholder()](/api/class-page.mdx#page-get-by-placeholder) 定位這類輸入欄位。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<input type="email" placeholder="name@example.com" />
</div>

```html
<input type="email" placeholder="name@example.com" />
```
</HTMLCard>

您可以透過預留位置文字定位輸入欄位後填入：

```js
await page
    .getByPlaceholder('name@example.com')
    .fill('playwright@microsoft.com');
```

:::note[何時使用預留位置定位器]
在定位沒有標籤但有預留位置文字的表單元素時使用此定位器。
:::

### 透過文字定位

透過元素包含的文字尋找元素。使用 [page.getByText()](/api/class-page.mdx#page-get-by-text) 時，您可以透過子字串、完全字串或正規表示式進行配對。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<span>Welcome, John</span>
</div>

```html
<span>Welcome, John</span>
```
</HTMLCard>

您可以透過元素包含的文字定位元素：

```js
await expect(page.getByText('Welcome, John')).toBeVisible();
```

設定完全配對：

```js
await expect(page.getByText('Welcome, John', { exact: true })).toBeVisible();
```

使用正規表示式配對：

```js
await expect(page.getByText(/welcome, [A-Za-z]+$/i)).toBeVisible();
```

:::note
透過文字配對始終會正規化空白字元，即使在完全配對的情況下也是如此。例如，它會將多個空格轉換為一個，將換行符轉換為空格，並忽略前導和後置空白字元。
:::

:::note[何時使用文字定位器]
我們建議使用文字定位器來尋找非互動元素，如 `div`、`span`、`p` 等。對於互動元素如 `button`、`a`、`input` 等，請使用[角色定位器](#locate-by-role)。
:::

您也可以[透過文字篩選](#filter-by-text)，這在嘗試在清單中尋找特定項目時很有用。

### 透過替代文字定位

所有圖片都應該有描述圖片的 `alt` 屬性。您可以使用 [page.getByAltText()](/api/class-page.mdx#page-get-by-alt-text) 根據文字替代內容定位圖片。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
</div>

```html
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
```
</HTMLCard>

您可以透過文字替代內容定位圖片後點擊：

```js
await page.getByAltText('playwright logo').click();
```

:::note[何時使用替代文字定位器]
當您的元素支援替代文字（如 `img` 和 `area` 元素）時使用此定位器。
:::

### 透過標題定位

使用 [page.getByTitle()](/api/class-page.mdx#page-get-by-title) 定位具有配對標題屬性的元素。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<span title='Issues count'>25 issues</span>
</div>

```html
<span title='Issues count'>25 issues</span>
```
</HTMLCard>

您可以透過標題文字定位後檢查問題計數：

```js
await expect(page.getByTitle('Issues count')).toHaveText('25 issues');
```

:::note[何時使用標題定位器]
當您的元素有 `title` 屬性時使用此定位器。
:::

### 透過測試 ID 定位

透過測試 ID 進行測試是最穩固的測試方式，因為即使文字或屬性的角色改變，測試仍會通過。QA 和開發人員應該定義明確的測試 ID，並使用 [page.getByTestId()](/api/class-page.mdx#page-get-by-test-id) 查詢它們。然而，透過測試 ID 測試不是面向使用者的。如果角色或文字值對您很重要，那麼考慮使用面向使用者的定位器，如[角色](#locate-by-role)和[文字定位器](#locate-by-text)。

例如，考慮以下 DOM 結構。

<HTMLCard>
<div>
<button data-testid="directions">Itinéraire</button>
</div>

```html
<button data-testid="directions">Itinéraire</button>
```
</HTMLCard>

您可以透過測試 ID 定位元素：

```js
await page.getByTestId('directions').click();
```

:::note[何時使用測試 ID 定位器]
當您選擇使用測試 ID 方法論或無法透過[角色](#locate-by-role)或[文字](#locate-by-text)定位時，您也可以使用測試 ID。
:::

#### 設定自訂測試 ID 屬性

預設情況下，[page.getByTestId()](/api/class-page.mdx#page-get-by-test-id) 將根據 `data-testid` 屬性定位元素，但您可以在測試組態中設定或透過呼叫 [selectors.setTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) 進行設定。

設定測試 ID 為您的測試使用自訂資料屬性。

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';

export default defineConfig({
  use: {
    testIdAttribute: 'data-pw'
  }
});
```

在您的 HTML 中，您現在可以使用 `data-pw` 作為測試 ID，而不是預設的 `data-testid`。

<HTMLCard>
<div>
<button data-pw="directions">Itinéraire</button>
</div>

```html
<button data-pw="directions">Itinéraire</button>
```
</HTMLCard>

And then locate the element as you would normally do:

```js
await page.getByTestId('directions').click();
```

### 使用 CSS 或 XPath 定位

如果您絕對必須使用 CSS 或 XPath 定位器，可以使用 [page.locator()](/api/class-page.mdx#page-locator) 建立定位器，該定位器接收選擇器來描述如何在頁面中尋找元素。Playwright 支援 CSS 和 XPath 選擇器，如果您省略 `css=` 或 `xpath=` 前綴，會自動偵測選擇器類型。

```js
await page.locator('css=button').click();
await page.locator('xpath=//button').click();

await page.locator('button').click();
await page.locator('//button').click();
```

XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:

```js
await page.locator(
    '#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input'
).click();

await page
    .locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input')
    .click();
```

:::note[何時使用此方法]
不建議使用 CSS 和 XPath，因為 DOM 經常變更可能導致測試不穩定。相反地，請嘗試想出更接近使用者感知頁面方式的定位器，例如[角色定位器](#locate-by-role)或使用測試 ID [定義明確的測試契約](#locate-by-test-id)。
:::

## Locate in Shadow DOM

All locators in Playwright **by default** work with elements in Shadow DOM. The exceptions are:
- Locating by XPath does not pierce shadow roots.
- [Closed-mode shadow roots](https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#parameters) are not supported.

考慮以下自訂網頁元件的範例：

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

您可以像 shadow root 不存在一樣進行定位。

要點擊 `<div>Details</div>`：

```js
await page.getByText('Details').click();
```

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

要點擊 `<x-details>`：

```js
await page.locator('x-details', { hasText: 'Details' }).click();
```

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

To ensure that `<x-details>` contains the text "Details":

```js
await expect(page.locator('x-details')).toContainText('Details');
```

## 篩選定位器

考慮以下 DOM 結構，我們想要點擊第二個產品卡片的購買按鈕。我們有幾個選項來篩選定位器以取得正確的目標。

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

### 依文字篩選

定位器可以使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 方法依文字篩選。它會在元素內某處搜尋特定字串，可能在子元素中，且不區分大小寫。您也可以傳遞正規表示式。

```js
await page
    .getByRole('listitem')
    .filter({ hasText: 'Product 2' })
    .getByRole('button', { name: 'Add to cart' })
    .click();
```

使用正規表示式：

```js
await page
    .getByRole('listitem')
    .filter({ hasText: /Product 2/ })
    .getByRole('button', { name: 'Add to cart' })
    .click();
```

### 依沒有文字篩選

或者，依**沒有**文字篩選：

```js
// 5 in-stock items
await expect(page.getByRole('listitem').filter({ hasNotText: 'Out of stock' })).toHaveCount(5);
```

### 依子項目/後代元素篩選

定位器支援只選擇有或沒有符合另一個定位器的子項目的元素選項。因此您可以依任何其他定位器篩選，例如 [locator.getByRole()](/api/class-locator.mdx#locator-get-by-role)、[locator.getByTestId()](/api/class-locator.mdx#locator-get-by-test-id)、[locator.getByText()](/api/class-locator.mdx#locator-get-by-text) 等。

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

```js
await page
    .getByRole('listitem')
    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) })
    .getByRole('button', { name: 'Add to cart' })
    .click();
```

我們也可以對產品卡片進行斷言，確保只有一個：

```js
await expect(page
    .getByRole('listitem')
    .filter({ has: page.getByRole('heading', { name: 'Product 2' }) }))
    .toHaveCount(1);
```

篩選定位器**必須相對**於原始定位器，並從原始定位器匹配開始查詢，而不是從文件根目錄開始。因此，以下方式不會生效，因為篩選定位器從 `<ul>` 清單元素開始匹配，該元素在原始定位器匹配的 `<li>` 清單項目之外：

```js
// ✖ WRONG
await expect(page
    .getByRole('listitem')
    .filter({ has: page.getByRole('list').getByText('Product 2') }))
    .toHaveCount(1);
```

### 依沒有子項目/後代元素篩選

我們也可以依**沒有**內部匹配元素進行篩選。

```js
await expect(page
    .getByRole('listitem')
    .filter({ hasNot: page.getByText('Product 2') }))
    .toHaveCount(1);
```

注意內部定位器從外部定位器開始匹配，而不是從文件根目錄開始。

## 定位器運算子

### 在定位器內匹配

您可以串連建立定位器的方法，例如 [page.getByText()](/api/class-page.mdx#page-get-by-text) 或 [locator.getByRole()](/api/class-locator.mdx#locator-get-by-role)，將搜尋範圍縮小到頁面的特定部分。

在此範例中，我們首先透過定位其 `listitem` 角色建立名為 product 的定位器。然後依文字篩選。我們可以再次使用 product 定位器取得按鈕角色並點擊它，然後使用斷言確保只有一個包含文字「Product 2」的產品。

```js
const product = page.getByRole('listitem').filter({ hasText: 'Product 2' });

await product.getByRole('button', { name: 'Add to cart' }).click();

await expect(product).toHaveCount(1);
```

您也可以將兩個定位器串連在一起，例如在特定對話框中尋找「儲存」按鈕：

```js
const saveButton = page.getByRole('button', { name: 'Save' });
// ...
const dialog = page.getByTestId('settings-dialog');
await dialog.locator(saveButton).click();
```

### 同時匹配兩個定位器

[locator.and()](/api/class-locator.mdx#locator-and) 方法透過匹配額外的定位器來縮小現有定位器的範圍。例如，您可以結合 [page.getByRole()](/api/class-page.mdx#page-get-by-role) 和 [page.getByTitle()](/api/class-page.mdx#page-get-by-title) 同時依角色和標題匹配。

```js
const button = page.getByRole('button').and(page.getByTitle('Subscribe'));
```

### 匹配兩個替代定位器之一

如果您想要鎖定兩個或更多元素中的一個，且不知道會是哪一個，請使用 [locator.or()](/api/class-locator.mdx#locator-or) 建立符合任一個或兩個替代方案的定位器。

例如，考慮一個想要點擊「新電子郵件」按鈕的情境，但有時會出現安全性設定對話框。在這種情況下，您可以等待「新電子郵件」按鈕或對話框並相應地採取行動。

:::note

如果「新電子郵件」按鈕和安全性對話框都出現在螢幕上，「or」定位器會匹配兩者，可能拋出[「嚴格模式違規」錯誤](#strictness)。在這種情況下，您可以使用 [locator.first()](/api/class-locator.mdx#locator-first) 只匹配其中一個。
:::

```js
const newEmail = page.getByRole('button', { name: 'New' });
const dialog = page.getByText('Confirm security settings');
await expect(newEmail.or(dialog).first()).toBeVisible();
if (await dialog.isVisible())
  await page.getByRole('button', { name: 'Dismiss' }).click();
await newEmail.click();
```

### 只匹配可見元素

:::note

通常最好找到[更可靠的方式](./locators.mdx#quick-guide)來唯一識別元素，而不是檢查可見性。
:::

考慮一個包含兩個按鈕的頁面，第一個不可見，第二個[可見](./actionability.mdx#visible)。

```html
<button style='display: none'>Invisible</button>
<button>Visible</button>
```

* This will find both buttons and throw a [strictness](./locators.mdx#strictness) violation error:
  
  ```js
  await page.locator('button').click();
  ```
  
* This will only find a second button, because it is visible, and then click it.
  
  ```js
  await page.locator('button').filter({ visible: true }).click();
  ```
  
## Lists

### Count items in a list

您可以對定位器進行斷言來計算清單中的項目數量。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

使用計數斷言確保清單有 3 個項目。

```js
await expect(page.getByRole('listitem')).toHaveCount(3);
```

### Assert all text in a list

您可以對定位器進行斷言來尋找清單中的所有文字。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

使用 [expect(locator).toHaveText()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) 確保清單包含文字「apple」、「banana」和「orange」。

```js
await expect(page
    .getByRole('listitem'))
    .toHaveText(['apple', 'banana', 'orange']);
```

### Get a specific item

有許多方式可以取得清單中的特定項目。

#### Get by text

使用 [page.getByText()](/api/class-page.mdx#page-get-by-text) 方法透過文字內容在清單中定位元素，然後點擊它。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

透過文字內容定位項目並點擊它。

```js
await page.getByText('orange').click();
```

#### Filter by text

使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 定位清單中的特定項目。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

透過 "listitem" 角色定位項目，然後依 "orange" 文字篩選並點擊。

```js
await page
    .getByRole('listitem')
    .filter({ hasText: 'orange' })
    .click();
```

#### Get by test id

使用 [page.getByTestId()](/api/class-page.mdx#page-get-by-test-id) 方法定位清單中的元素。如果您還沒有測試 ID，可能需要修改 HTML 並加入測試 ID。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
</div>

```html
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
```
</HTMLCard>

透過測試 ID "orange" 定位項目並點擊。

```js
await page.getByTestId('orange').click();
```

#### Get by nth item

如果您有一個相同元素的清單，而唯一能區別它們的方式是順序，您可以使用 [locator.first()](/api/class-locator.mdx#locator-first)、[locator.last()](/api/class-locator.mdx#locator-last) 或 [locator.nth()](/api/class-locator.mdx#locator-nth) 從清單中選擇特定元素。

```js
const banana = await page.getByRole('listitem').nth(1);
```

然而，使用此方法時要小心。通常頁面可能會變更，定位器會指向與您預期完全不同的元素。相反地，嘗試想出通過[嚴格性條件](#strictness)的唯一定位器。

### Chaining filters

當您有具有各種相似性的元素時，可以使用 [locator.filter()](/api/class-locator.mdx#locator-filter) 方法選擇正確的元素。您也可以鏈接多個篩選器以縮小選擇範圍。

For example, consider the following DOM structure:

<HTMLCard>
<div>
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
```
</HTMLCard>

To take a screenshot of the row with "Mary" and "Say goodbye":

```js
const rowLocator = page.getByRole('listitem');

await rowLocator
    .filter({ hasText: 'Mary' })
    .filter({ has: page.getByRole('button', { name: 'Say goodbye' }) })
    .screenshot({ path: 'screenshot.png' });
```

現在您的專案根目錄中應該有一個 "screenshot.png" 檔案。

### Rare use cases

#### Do something with each element in the list

Iterate elements:

```js
for (const row of await page.getByRole('listitem').all())
  console.log(await row.textContent());
```

Iterate using regular for loop:

```js
const rows = page.getByRole('listitem');
const count = await rows.count();
for (let i = 0; i < count; ++i)
  console.log(await rows.nth(i).textContent());
```

#### Evaluate in the page

[locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all) 內的程式碼在頁面中執行，您可以在那裡呼叫任何 DOM API。

```js
const rows = page.getByRole('listitem');
const texts = await rows.evaluateAll(
    list => list.map(element => element.textContent));
```

## 嚴格性

定位器是嚴格的。這意味著對定位器執行的所有暗示某個目標 DOM 元素的操作，如果有多個元素匹配，會拋出例外。例如，如果 DOM 中有多個按鈕，以下呼叫會拋出例外：

#### 如果有多個會拋出錯誤

```js
await page.getByRole('button').click();
```

另一方面，Playwright 會理解您何時執行多元素操作，所以當定位器解析為多個元素時，以下呼叫運作完全正常。

#### 對多個元素運作正常

```js
await page.getByRole('button').count();
```

您可以透過 [locator.first()](/api/class-locator.mdx#locator-first)、[locator.last()](/api/class-locator.mdx#locator-last) 和 [locator.nth()](/api/class-locator.mdx#locator-nth) 告訴 Playwright 當多個元素匹配時要使用哪個元素，明確選擇退出嚴格性檢查。這些方法**不建議使用**，因為當您的頁面變更時，Playwright 可能會點擊您無意的元素。相反地，請遵循上述最佳實踐建立唯一識別目標元素的定位器。

## 更多定位器

對於較少使用的定位器，請查看[其他定位器](./other-locators.mdx)指南。


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[GenericAssertions]: /api/class-genericassertions.mdx "GenericAssertions"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[SnapshotAssertions]: /api/class-snapshotassertions.mdx "SnapshotAssertions"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[FullConfig]: /api/class-fullconfig.mdx "FullConfig"
[FullProject]: /api/class-fullproject.mdx "FullProject"
[Location]: /api/class-location.mdx "Location"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestInfoError]: /api/class-testinfoerror.mdx "TestInfoError"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[TestStepInfo]: /api/class-teststepinfo.mdx "TestStepInfo"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestError]: /api/class-testerror.mdx "TestError"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date "Date"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData "FormData"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[Metadata]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object&lt;string, any&gt;"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[ReadStream]: https://nodejs.org/api/fs.html#class-fsreadstream "ReadStream"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"
[URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams "URLSearchParams"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
