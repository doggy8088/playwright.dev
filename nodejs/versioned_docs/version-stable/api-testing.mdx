---
id: api-testing
title: "API 測試"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## 簡介

Playwright 可以用來存取你的應用程式的 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) API。

有時你可能想要直接從 Node.js 向伺服器發送請求，而不需要加載頁面並在其中執行 js 程式碼。以下是一些可能會派上用場的範例:

- 測試你的伺服器 API。
- 在測試中訪問 web 應用程式之前準備伺服器端狀態。
- 在瀏覽器中執行一些操作後驗證伺服器端後置條件。

所有這些都可以通過 [APIRequestContext] 方法實現。

## 撰寫 API 測試

[APIRequestContext] 可以透過網路發送各種 HTTP(S) 請求。

以下範例展示如何使用 Playwright 測試通過 [GitHub API](https://docs.github.com/en/rest) 建立問題。測試套件將執行以下操作：

- 建立一個新的儲存庫後執行測試。
- 建立一些問題並驗證伺服器狀態。
- 執行測試後刪除儲存庫。

### 設定

GitHub API 需要授權，因此我們將為所有測試設定一次性 token。在此同時，我們也會設定 `baseURL` 以簡化測試。你可以將它們放在配置文件中，或者在測試文件中使用 `test.use()`。

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';
export default defineConfig({
  use: {
    // All requests we send go to this API endpoint.
    baseURL: 'https://api.github.com',
    extraHTTPHeaders: {
      // We set this header per GitHub guidelines.
      'Accept': 'application/vnd.github.v3+json',
      // Add authorization token to all requests.
      // Assuming personal access token available in the environment.
      'Authorization': `token ${process.env.API_TOKEN}`,
    },
  }
});
```

**代理配置**

如果你的測試需要在代理伺服器後面執行，你可以在配置中指定這一點，`request` 固定裝置會自動選取它:

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';
export default defineConfig({
  use: {
    proxy: {
      server: 'http://my-proxy:8080',
      username: 'user',
      password: 'secret'
    },
  }
});
```

### 撰寫測試

Playwright Test 內建 `request` fixture，遵循我們指定的 `baseURL` 或 `extraHTTPHeaders` 等配置選項，並準備發送一些請求。

現在我們可以新增一些測試，這些測試將在儲存庫中建立新的問題。

```js
const REPO = 'test-repo-1';
const USER = 'github-username';

test('should create a bug report', async ({ request }) => {
  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {
    data: {
      title: '[Bug] report 1',
      body: 'Bug description',
    }
  });
  expect(newIssue.ok()).toBeTruthy();

  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);
  expect(issues.ok()).toBeTruthy();
  expect(await issues.json()).toContainEqual(expect.objectContaining({
    title: '[Bug] report 1',
    body: 'Bug description'
  }));
});

test('should create a feature request', async ({ request }) => {
  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {
    data: {
      title: '[Feature] request 1',
      body: 'Feature description',
    }
  });
  expect(newIssue.ok()).toBeTruthy();

  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);
  expect(issues.ok()).toBeTruthy();
  expect(await issues.json()).toContainEqual(expect.objectContaining({
    title: '[Feature] request 1',
    body: 'Feature description'
  }));
});
```

### 設定和拆卸

這些測試假設資料庫已存在。你可能想在執行測試之前建立一個新的，並在之後刪除它。使用 `beforeAll` 和 `afterAll` 鉤子來實現。

```js
test.beforeAll(async ({ request }) => {
  // Create a new repository
  const response = await request.post('/user/repos', {
    data: {
      name: REPO
    }
  });
  expect(response.ok()).toBeTruthy();
});

test.afterAll(async ({ request }) => {
  // Delete the repository
  const response = await request.delete(`/repos/${USER}/${REPO}`);
  expect(response.ok()).toBeTruthy();
});
```

## 使用請求上下文

幕後，[`request` fixture](./api/class-fixtures#fixtures-request) 實際上會呼叫 [apiRequest.newContext()]( /api/class-apirequest.mdx#api-request-new-context)。如果你想要更多控制權，你可以手動執行。以下是一個獨立的腳本，它與上面的 `beforeAll` 和 `afterAll` 做同樣的事情。

```js
import { request } from '@playwright/test';
const REPO = 'test-repo-1';
const USER = 'github-username';

(async () => {
  // Create a context that will issue http requests.
  const context = await request.newContext({
    baseURL: 'https://api.github.com',
  });

  // Create a repository.
  await context.post('/user/repos', {
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      // Add GitHub personal access token.
      'Authorization': `token ${process.env.API_TOKEN}`,
    },
    data: {
      name: REPO
    }
  });

  // Delete a repository.
  await context.delete(`/repos/${USER}/${REPO}`, {
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      // Add GitHub personal access token.
      'Authorization': `token ${process.env.API_TOKEN}`,
    }
  });
})();
```

## 從 UI 測試發送 API 請求

在瀏覽器內執行測試時，您可能希望呼叫應用程式的 HTTP API。如果您需要在執行測試之前準備伺服器狀態或在瀏覽器中執行某些操作後檢查伺服器上的一些後置條件，這可能會很有幫助。所有這些都可以通過 [APIRequestContext] 方法來實現。

### 建立前提條件

以下測試通過 API 建立一個新問題，然後導航到專案中所有問題的列表，以檢查它是否出現在列表頂部。

```js
import { test, expect } from '@playwright/test';

const REPO = 'test-repo-1';
const USER = 'github-username';

// Request context is reused by all tests in the file.
let apiContext;

test.beforeAll(async ({ playwright }) => {
  apiContext = await playwright.request.newContext({
    // All requests we send go to this API endpoint.
    baseURL: 'https://api.github.com',
    extraHTTPHeaders: {
      // We set this header per GitHub guidelines.
      'Accept': 'application/vnd.github.v3+json',
      // Add authorization token to all requests.
      // Assuming personal access token available in the environment.
      'Authorization': `token ${process.env.API_TOKEN}`,
    },
  });
});

test.afterAll(async ({ }) => {
  // Dispose all responses.
  await apiContext.dispose();
});

test('last created issue should be first in the list', async ({ page }) => {
  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {
    data: {
      title: '[Feature] request 1',
    }
  });
  expect(newIssue.ok()).toBeTruthy();

  await page.goto(`https://github.com/${USER}/${REPO}/issues`);
  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();
  await expect(firstIssue).toHaveText('[Feature] request 1');
});
```

### 驗證後置條件

以下測試通過瀏覽器中的使用者介面建立一個新問題，然後使用檢查是否通過 API 建立:

```js
import { test, expect } from '@playwright/test';

const REPO = 'test-repo-1';
const USER = 'github-username';

// Request context is reused by all tests in the file.
let apiContext;

test.beforeAll(async ({ playwright }) => {
  apiContext = await playwright.request.newContext({
    // All requests we send go to this API endpoint.
    baseURL: 'https://api.github.com',
    extraHTTPHeaders: {
      // We set this header per GitHub guidelines.
      'Accept': 'application/vnd.github.v3+json',
      // Add authorization token to all requests.
      // Assuming personal access token available in the environment.
      'Authorization': `token ${process.env.API_TOKEN}`,
    },
  });
});

test.afterAll(async ({ }) => {
  // Dispose all responses.
  await apiContext.dispose();
});

test('last created issue should be on the server', async ({ page }) => {
  await page.goto(`https://github.com/${USER}/${REPO}/issues`);
  await page.getByText('New Issue').click();
  await page.getByRole('textbox', { name: 'Title' }).fill('Bug report 1');
  await page.getByRole('textbox', { name: 'Comment body' }).fill('Bug description');
  await page.getByText('Submit new issue').click();
  const issueId = page.url().substr(page.url().lastIndexOf('/'));

  const newIssue = await apiContext.get(
      `https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`
  );
  expect(newIssue.ok()).toBeTruthy();
  expect(newIssue.json()).toEqual(expect.objectContaining({
    title: 'Bug report 1'
  }));
});
```

## 重複使用認證狀態

Web apps 使用基於 cookie 或 token 的身份驗證，已驗證的狀態存儲為 [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)。Playwright 提供 [apiRequestContext.storageState()](/api/class-apirequestcontext.mdx#api-request-context-storage-state) 方法，可以用來從已驗證的上下文中檢索存儲狀態，然後使用該狀態建立新的上下文。

儲存狀態在 [BrowserContext] 和 [APIRequestContext] 之間是可互換的。你可以使用它通過 API 呼叫登入，然後建立一個已經包含 cookies 的新 context。以下程式碼片段從已驗證的 [APIRequestContext] 中檢索狀態，並使用該狀態建立一個新的 [BrowserContext]。

```js
const requestContext = await request.newContext({
  httpCredentials: {
    username: 'user',
    password: 'passwd'
  }
});
await requestContext.get(`https://api.example.com/login`);
// Save storage state into the file.
await requestContext.storageState({ path: 'state.json' });

// Create a new context with the saved storage state.
const context = await browser.newContext({ storageState: 'state.json' });
```

## Context request vs 全域 request

有兩種類型的 [APIRequestContext]：

* 與 [BrowserContext] 相關
* 建立的隔離實例，通過 [apiRequest.newContext()](/api/class-apirequest.mdx#api-request-new-context)

主要的區別在於通過 [browserContext.request](/api/class-browsercontext.mdx#browser-context-request) 和 [page.request](/api/class-page.mdx#page-request) 訪問的 [APIRequestContext] 會從瀏覽器 context 填充請求的 `Cookie` 標頭，並且如果 [APIResponse] 有 `Set-Cookie` 標頭，則會自動更新瀏覽器 cookies：

```js
test('context request will share cookie storage with its browser context', async ({
  page,
  context,
}) => {
  await context.route('https://www.github.com/', async route => {
    // Send an API request that shares cookie storage with the browser context.
    const response = await context.request.fetch(route.request());
    const responseHeaders = response.headers();

    // The response will have 'Set-Cookie' header.
    const responseCookies = new Map(responseHeaders['set-cookie']
        .split('\n')
        .map(c => c.split(';', 2)[0].split('=')));
    // The response will have 3 cookies in 'Set-Cookie' header.
    expect(responseCookies.size).toBe(3);
    const contextCookies = await context.cookies();
    // The browser context will already contain all the cookies from the API response.
    expect(new Map(contextCookies.map(({ name, value }) =>
      [name, value])
    )).toEqual(responseCookies);

    await route.fulfill({
      response,
      headers: { ...responseHeaders, foo: 'bar' },
    });
  });
  await page.goto('https://www.github.com/');
});
```

如果你不希望 [APIRequestContext] 使用和更新來自瀏覽器上下文的 cookies，你可以手動建立一個新的 [APIRequestContext] 實例，這將擁有其自身隔離的 cookies:

```js
test('global context request has isolated cookie storage', async ({
  page,
  context,
  browser,
  playwright
}) => {
  // Create a new instance of APIRequestContext with isolated cookie storage.
  const request = await playwright.request.newContext();
  await context.route('https://www.github.com/', async route => {
    const response = await request.fetch(route.request());
    const responseHeaders = response.headers();

    const responseCookies = new Map(responseHeaders['set-cookie']
        .split('\n')
        .map(c => c.split(';', 2)[0].split('=')));
    // The response will have 3 cookies in 'Set-Cookie' header.
    expect(responseCookies.size).toBe(3);
    const contextCookies = await context.cookies();
    // The browser context will not have any cookies from the isolated API request.
    expect(contextCookies.length).toBe(0);

    // Manually export cookie storage.
    const storageState = await request.storageState();
    // Create a new context and initialize it with the cookies from the global request.
    const browserContext2 = await browser.newContext({ storageState });
    const contextCookies2 = await browserContext2.cookies();
    // The new browser context will already contain all the cookies from the API response.
    expect(
        new Map(contextCookies2.map(({ name, value }) => [name, value]))
    ).toEqual(responseCookies);

    await route.fulfill({
      response,
      headers: { ...responseHeaders, foo: 'bar' },
    });
  });
  await page.goto('https://www.github.com/');
  await request.dispose();
});
```




[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[GenericAssertions]: /api/class-genericassertions.mdx "GenericAssertions"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[SnapshotAssertions]: /api/class-snapshotassertions.mdx "SnapshotAssertions"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[FullConfig]: /api/class-fullconfig.mdx "FullConfig"
[FullProject]: /api/class-fullproject.mdx "FullProject"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestInfoError]: /api/class-testinfoerror.mdx "TestInfoError"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Location]: /api/class-location.mdx "Location"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestError]: /api/class-testerror.mdx "TestError"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData "FormData"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[Metadata]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object&lt;string, any&gt;"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[ReadStream]: https://nodejs.org/api/fs.html#class-fsreadstream "ReadStream"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"
[URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams "URLSearchParams"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/about "Microsoft Artifact Registry"
[Dockerfile.jammy]: https://github.com/microsoft/playwright/blob/main/utils/docker/Dockerfile.jammy "Dockerfile.jammy"
